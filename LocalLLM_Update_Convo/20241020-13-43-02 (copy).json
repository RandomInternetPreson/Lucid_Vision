{
    "internal": [
        [
            "<|BEGIN-VISIBLE-CHAT|>",
            "How can I help you today?"
        ],
        [
            "I have this code called LucidVision.py.  I want to integrate two new models GOT-OCR and Aria.  Both of these models are unique to the LucidVision.py code, however I have them successfully integrated into code called script.py\n\nGOT-OCR is an ocr model and does not accept user questions, please note that in the script.py code; and Aria is a large model that cannot be loaded onto one gpu like the other lucid vision models, note this in the script.py code.\n\nLucidVision.py:\n```\n# pip install pexpect\nimport json\nimport re\nfrom datetime import datetime  # Import datetime for timestamp generation\nfrom pathlib import Path\n\nimport gradio as gr\nimport torch\nfrom PIL import Image\nfrom deepseek_vl.models import VLChatProcessor\nfrom deepseek_vl.utils.io import load_pil_images as load_pil_images_for_deepseek\nfrom transformers import AutoModelForCausalLM, AutoModel, AutoTokenizer, AutoProcessor, \\\n    PaliGemmaForConditionalGeneration\n\nmodel_names = [\"phiVision\", \"DeepSeek\", \"paligemma\", \"paligemma_cpu\", \"minicpm_llama3\", \"bunny\"]\n\n\n# Load configuration settings from a JSON file\ndef load_config():\n    with open(Path(__file__).parent / \"config.json\", \"r\") as config_file:\n        # Read and parse the JSON configuration file\n        config = json.load(config_file)\n    return config\n\n\n# Load the configuration settings at the module level\nconfig = load_config()\n\n# Define the model ID for PhiVision using the configuration setting\nphiVision_model_id = config[\"phiVision_model_id\"]\n\n# Define the model ID for PaliGemma using the configuration setting\npaligemma_model_id = config[\"paligemma_model_id\"]\n\nminicpm_llama3_model_id = config[\"minicpm_llama3_model_id\"]\n\nbunny_model_id = config[\"bunny_model_id\"]\n\ncuda_device = config[\"cuda_visible_devices\"]\n\nselected_vision_model = config[\"default_vision_model\"]\n\n# Global variable to store the file path of the selected image\nselected_image_path = None\n\n# Define the directory where the image files will be saved\n# This path is loaded from the configuration file\nimage_history_dir = Path(config[\"image_history_dir\"])\n# Ensure the directory exists, creating it if necessary\nimage_history_dir.mkdir(parents=True, exist_ok=True)\n\nglobal phiVision_model, phiVision_processor\nglobal minicpm_llama_model, minicpm_llama_tokenizer\nglobal paligemma_model, paligemma_processor\nglobal paligemma_cpu_model, paligemma_cpu_processor\nglobal deepseek_processor, deepseek_tokenizer, deepseek_gpt\nglobal bunny_model, bunny_tokenizer\n\n\n# Function to generate a timestamped filename for saved images\ndef get_timestamped_filename(extension=\".png\"):\n    # Generate a timestamp in the format YYYYMMDD_HHMMSS\n    timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    # Return a formatted file name with the timestamp\n    return f\"image_{timestamp}{extension}\"\n\n\n# Function to modify the user input before it is processed by the LLM\ndef input_modifier(user_input, state):\n    global selected_image_path\n    # Check if an image has been selected and stored in the global variable\n    if selected_image_path:\n        # Construct the message with the \"File location\" trigger phrase and the image file path\n        image_info = f\"File location: {selected_image_path}\"\n        # Combine the user input with the image information, separated by a newline for clarity\n        combined_input = f\"{user_input}\\n\\n{image_info}\"\n        # Reset the selected image path to None after processing\n        selected_image_path = None\n        return combined_input\n    # If no image is selected, return the user input as is\n    return user_input\n\n\n# Function to handle image upload and store the file path\ndef save_and_print_image_path(image):\n    global selected_image_path\n    if image is not None:\n        # Generate a unique timestamped filename for the image\n        file_name = get_timestamped_filename()\n        # Construct the full file path for the image\n        file_path = image_history_dir / file_name\n        # Save the uploaded image to the specified directory\n        image.save(file_path, format='PNG')\n        print(f\"Image selected: {file_path}\")\n        # Update the global variable with the new image file path\n        selected_image_path = file_path\n    else:\n        # Print a message if no image is selected\n        print(\"No image selected yet.\")\n\n\n# Function to create the Gradio UI components with the new direct vision model interaction elements\ndef ui():\n    # Create an image input component for the Gradio UI\n    image_input = gr.Image(label=\"Select an Image\", type=\"pil\", source=\"upload\")\n    # Set up the event that occurs when an image is uploaded\n    image_input.change(\n        fn=save_and_print_image_path,\n        inputs=image_input,\n        outputs=None\n    )\n\n    # Create a text field for user input to the vision model\n    user_input_to_vision_model = gr.Textbox(label=\"Type your question or prompt for the vision model\", lines=2,\n                                            placeholder=\"Enter your text here...\")\n\n    # Create a button to trigger the vision model processing\n    vision_model_button = gr.Button(value=\"Ask Vision Model\")\n\n    # Create a text field to display the vision model's response\n    vision_model_response_output = gr.Textbox(\n        label=\"Vision Model Response\",\n        lines=5,\n        placeholder=\"Response will appear here...\"\n    )\n\n    # Add radio buttons for vision model selection\n    vision_model_selection = gr.Radio(\n        choices=model_names,\n        # Added \"paligemma_cpu\" as a choice\n        value=config[\"default_vision_model\"],\n        label=\"Select Vision Model\"\n    )\n\n    # Add an event handler for the radio button selection\n    vision_model_selection.change(\n        fn=update_vision_model,\n        inputs=vision_model_selection,\n        outputs=None\n    )\n\n    cuda_devices_input = gr.Textbox(\n        value=cuda_device,\n        label=\"CUDA Device ID\",\n        max_lines=1\n    )\n\n    cuda_devices_input.change(\n        fn=update_cuda_device,\n        inputs=cuda_devices_input,\n        outputs=None\n    )\n\n    # Set up the event that occurs when the vision model button is clicked\n    vision_model_button.click(\n        fn=process_with_vision_model,\n        inputs=[user_input_to_vision_model, image_input, vision_model_selection],\n        # Pass the actual gr.Image component\n        outputs=vision_model_response_output\n    )\n\n    # Return a column containing the UI components\n    return gr.Column(\n        [\n            image_input,\n            user_input_to_vision_model,\n            vision_model_button,\n            vision_model_response_output,\n            vision_model_selection\n        ]\n    )\n\n\n# Function to load the PaliGemma CPU model and processor\ndef load_paligemma_cpu_model():\n    global paligemma_cpu_model, paligemma_cpu_processor\n    paligemma_cpu_model = PaliGemmaForConditionalGeneration.from_pretrained(\n        paligemma_model_id,\n    ).eval()\n    paligemma_cpu_processor = AutoProcessor.from_pretrained(paligemma_model_id)\n    print(\"PaliGemma CPU model loaded on-demand.\")\n\n\n# Function to unload the PaliGemma CPU model and processor\ndef unload_paligemma_cpu_model():\n    global paligemma_cpu_model, paligemma_cpu_processor\n    if paligemma_cpu_model is not None:\n        # Delete the model and processor instances\n        del paligemma_cpu_model\n        del paligemma_cpu_processor\n        print(\"PaliGemma CPU model unloaded.\")\n\n    # Global variable to store the selected vision model\n\n\n# Function to update the selected vision model and load the corresponding model\ndef update_vision_model(model_name):\n    global selected_vision_model\n    selected_vision_model = model_name\n    return model_name\n\n\ndef update_cuda_device(device):\n    global cuda_device\n    print(f\"Cuda device set to index = {device}\")\n    cuda_device = int(device)\n    return cuda_device\n\n\n# Main entry point for the Gradio interface\nif __name__ == \"__main__\":\n    # Launch the Gradio interface with the specified UI components\n    gr.Interface(\n        fn=ui,\n        inputs=None,\n        outputs=\"ui\"\n    ).launch()\n\n# Define a regular expression pattern to match the \"File location\" trigger phrase\nfile_location_pattern = re.compile(r\"File location: (.+)$\", re.MULTILINE)\n# Define a regular expression pattern to match and remove unwanted initial text\nunwanted_initial_text_pattern = re.compile(r\".*?prod\\(dim=0\\)\\r\\n\", re.DOTALL)\n\n# Define a regular expression pattern to match and remove unwanted prefixes from DeepSeek responses\n# This pattern should be updated to match the new, platform-independent file path format\nunwanted_prefix_pattern = re.compile(\n    r\"^\" + re.escape(str(image_history_dir)) + r\"[^ ]+\\.png\\s*Assistant: \",\n    re.MULTILINE\n)\n\n\n# Function to load the PhiVision model and processor\ndef load_phi_vision_model():\n    global phiVision_model, phiVision_processor, cuda_device\n    # Load the PhiVision model and processor on-demand, specifying the device map\n    phiVision_model = AutoModelForCausalLM.from_pretrained(\n        phiVision_model_id,\n        device_map={\"\": cuda_device},  # Use the specified CUDA device(s)\n        trust_remote_code=True,\n        torch_dtype=\"auto\"\n    )\n    phiVision_processor = AutoProcessor.from_pretrained(\n        phiVision_model_id,\n        trust_remote_code=True\n    )\n    print(\"PhiVision model loaded on-demand.\")\n\n\n# Function to unload the PhiVision model and processor\ndef unload_phi_vision_model():\n    global phiVision_model, phiVision_processor\n    if phiVision_model is not None:\n        # Delete the model and processor instances\n        del phiVision_model\n        del phiVision_processor\n        # Clear the CUDA cache to free up VRAM\n        torch.cuda.empty_cache()\n        print(\"PhiVision model unloaded.\")\n\n\n# Function to load the MiniCPM-Llama3 model and tokenizer\ndef load_minicpm_llama_model():\n    global minicpm_llama_model, minicpm_llama_tokenizer, cuda_device\n    if \"int4\" in minicpm_llama3_model_id:\n        # Load the 4-bit quantized model and tokenizer\n        minicpm_llama_model = AutoModel.from_pretrained(\n            minicpm_llama3_model_id,\n            device_map={\"\": cuda_device},\n            trust_remote_code=True,\n            torch_dtype=torch.float16  # Use float16 as per the example code for 4-bit models\n        ).eval()\n        minicpm_llama_tokenizer = AutoTokenizer.from_pretrained(\n            minicpm_llama3_model_id,\n            trust_remote_code=True\n        )\n        # Print a message indicating that the 4-bit model is loaded\n        print(\"MiniCPM-Llama3 4-bit quantized model loaded on-demand.\")\n    else:\n        # Load the standard model and tokenizer\n        minicpm_llama_model = AutoModel.from_pretrained(\n            minicpm_llama3_model_id,\n            device_map={\"\": cuda_device},  # Use the specified CUDA device\n            trust_remote_code=True,\n            torch_dtype=torch.bfloat16\n        ).eval()\n        minicpm_llama_tokenizer = AutoTokenizer.from_pretrained(\n            minicpm_llama3_model_id,\n            trust_remote_code=True\n        )\n        print(\"MiniCPM-Llama3 standard model loaded on-demand.\")\n\n\ndef unload_minicpm_llama_model():\n    global minicpm_llama_model, minicpm_llama_tokenizer\n    if minicpm_llama_model is not None:\n        del minicpm_llama_model\n        del minicpm_llama_tokenizer\n        torch.cuda.empty_cache()\n        print(\"MiniCPM-Llama3 model unloaded.\")\n\n\n# Function to load the PaliGemma model and processor\ndef load_paligemma_model():\n    global paligemma_model, paligemma_processor, cuda_device\n    # Load the PaliGemma model and processor on-demand, specifying the device map\n    paligemma_model = PaliGemmaForConditionalGeneration.from_pretrained(\n        paligemma_model_id,\n        device_map={\"\": cuda_device},  # Use the specified CUDA device(s)\n        torch_dtype=torch.bfloat16,\n        revision=\"bfloat16\",\n    ).eval()\n    paligemma_processor = AutoProcessor.from_pretrained(paligemma_model_id)\n    print(\"PaliGemma model loaded on-demand.\")\n\n\n# Function to unload the PaliGemma model and processor\ndef unload_paligemma_model():\n    global paligemma_model, paligemma_processor\n    if paligemma_model is not None:\n        # Delete the model and processor instances\n        del paligemma_model\n        del paligemma_processor\n        # Clear the CUDA cache to free up VRAM\n        torch.cuda.empty_cache()\n        print(\"PaliGemma model unloaded.\")\n\n\ndef load_deepseek_model():\n    global deepseek_processor, deepseek_tokenizer, deepseek_gpt, cuda_device\n    deepseek_processor = VLChatProcessor.from_pretrained(config[\"deepseek_vl_model_id\"])\n    deepseek_tokenizer = deepseek_processor.tokenizer\n    deepseek_gpt = AutoModelForCausalLM.from_pretrained(\n        config[\"deepseek_vl_model_id\"],\n        device_map={\"\": cuda_device},\n        trust_remote_code=True,\n        torch_dtype=torch.bfloat16\n    ).to(torch.bfloat16).cuda().eval()\n    print(\"DeepSeek model loaded on-demand.\")\n\n\ndef unload_deepseek_model():\n    global deepseek_processor, deepseek_tokenizer, deepseek_gpt\n    if deepseek_processor is not None:\n        del deepseek_gpt\n        del deepseek_tokenizer\n        del deepseek_processor\n        print(\"DeepSeek model unloaded.\")\n    torch.cuda.empty_cache()\n\n\ndef load_bunny_model():\n    global bunny_model, bunny_tokenizer, cuda_device\n    torch.cuda.set_device(cuda_device)  # Set default device before loading models\n    bunny_model = AutoModelForCausalLM.from_pretrained(\n        bunny_model_id,\n        torch_dtype=torch.bfloat16,\n        device_map={\"\": cuda_device},  # Use the specified CUDA device\n        trust_remote_code=True\n    ).to(torch.bfloat16).cuda()\n    bunny_tokenizer = AutoTokenizer.from_pretrained(\n        bunny_model_id,\n        trust_remote_code=True\n    )\n    print(\"Bunny model loaded on-demand.\")\n\n\ndef unload_bunny_model():\n    global bunny_model, bunny_tokenizer\n    if bunny_model is not None:\n        del bunny_model, bunny_tokenizer\n        print(\"Bunny model unloaded.\")\n    torch.cuda.empty_cache()\n\n\n# Function to modify the output from the LLM before it is displayed to the user\ndef output_modifier(output, state, is_chat=False):\n    global cuda_device\n    # Search for the \"File location\" trigger phrase in the LLM's output\n    file_location_matches = file_location_pattern.findall(output)\n    if file_location_matches:\n        # Extract the first match (assuming only one file location per output)\n        file_path = file_location_matches[0]\n        # Extract the questions for the vision model\n        questions_section, _ = output.split(f\"File location: {file_path}\", 1)\n        # Remove all newlines from the questions section and replace them with spaces\n        questions = \" \".join(questions_section.strip().splitlines())\n\n        # Initialize an empty response string\n        vision_model_response = \"\"\n\n        # Check which vision model is currently selected\n        if selected_vision_model == \"phiVision\":\n            vision_model_response = generate_phi_vision(file_path, questions)\n\n        elif selected_vision_model == \"DeepSeek\":\n            vision_model_response = generate_deepseek(file_path, questions)\n\n        elif selected_vision_model == \"paligemma\":\n            vision_model_response = generate_paligemma(file_path, questions)\n\n        elif selected_vision_model == \"paligemma_cpu\":\n            vision_model_response = generate_paligemma_cpu(file_path, questions)\n\n        elif selected_vision_model == \"minicpm_llama3\":\n            vision_model_response = generate_minicpm_llama3(file_path, questions)\n\n        elif selected_vision_model == \"bunny\":\n            vision_model_response = generate_bunny(file_path, questions)\n\n        # Append the vision model's responses to the output\n        output_with_responses = f\"{output}\\n\\nVision Model Responses:\\n{vision_model_response}\"\n        return output_with_responses\n    # If no file location is found, return the output as is\n    return output\n\n\n# Function to generate a response using the MiniCPM-Llama3 model\ndef generate_minicpm_llama3(file_path, questions):\n    global cuda_device\n    try:\n        load_minicpm_llama_model()\n        image = Image.open(file_path).convert(\"RGB\")\n        messages = [\n            {\"role\": \"user\", \"content\": f\"{questions}\"}\n        ]\n        # Define the generation arguments\n        generation_args = {\n            \"max_new_tokens\": 896,\n            \"repetition_penalty\": 1.05,\n            \"num_beams\": 3,\n            \"top_p\": 0.8,\n            \"top_k\": 1,\n            \"temperature\": 0.7,\n            \"sampling\": True,\n        }\n        if \"int4\" in minicpm_llama3_model_id:\n            # Disable streaming for the 4-bit model\n            generation_args[\"stream\"] = False\n            # Use the model.chat method with streaming enabled\n            vision_model_response = \"\"\n            for new_text in minicpm_llama_model.chat(\n                    image=image,\n                    msgs=messages,\n                    tokenizer=minicpm_llama_tokenizer,\n                    **generation_args\n            ):\n                vision_model_response += new_text\n                print(new_text, flush=True, end='')\n        else:\n            minicpm_llama_model.to(f\"cuda:{cuda_device}\")\n            vision_model_response = minicpm_llama_model.chat(\n                image=image,\n                msgs=messages,\n                tokenizer=minicpm_llama_tokenizer,\n                **generation_args\n            )\n            return vision_model_response\n    finally:\n        unload_minicpm_llama_model()\n\n\n# Function to process the user's input text and selected image with the vision model\ndef process_with_vision_model(user_input, image, selected_model):\n    global cuda_device\n    # Save the uploaded image to the specified directory with a timestamp\n    file_name = get_timestamped_filename()\n    file_path = image_history_dir / file_name\n    image.save(file_path, format='PNG')\n    print(f\"Image processed: {file_path}\")\n\n    # Initialize an empty response string\n    vision_model_response = \"\"\n\n    # Check which vision model is currently selected\n    if selected_model == \"phiVision\":\n        vision_model_response = generate_phi_vision(file_path, user_input)\n\n    elif selected_model == \"DeepSeek\":\n        vision_model_response = generate_deepseek(file_path, user_input)\n\n    elif selected_model == \"paligemma\":\n        vision_model_response = generate_paligemma(file_path, user_input)\n\n    elif selected_model == \"paligemma_cpu\":\n        vision_model_response = generate_paligemma_cpu(file_path, user_input)\n\n    elif selected_model == \"minicpm_llama3\":\n        vision_model_response = generate_minicpm_llama3(file_path, user_input)\n\n    elif selected_model == \"bunny\":\n        vision_model_response = generate_bunny(file_path, user_input)\n\n    # Return the cleaned-up response from the vision model\n    return vision_model_response\n\n\ndef generate_paligemma_cpu(file_path, user_input):\n    try:\n        # Load the PaliGemma CPU model and processor on-demand\n        load_paligemma_cpu_model()\n        # Load the saved image using PIL\n        with Image.open(file_path) as img:\n            # Prepare the prompt for the PaliGemma CPU model using the user's question\n            prompt = user_input\n            model_inputs = paligemma_cpu_processor(text=prompt, images=img, return_tensors=\"pt\")\n            input_len = model_inputs[\"input_ids\"].shape[-1]\n            # Generate the response using the PaliGemma CPU model\n            with torch.inference_mode():\n                generation = paligemma_cpu_model.generate(\n                    **model_inputs,\n                    max_new_tokens=100,\n                    do_sample=True  # Set to True for sampling-based generation\n                )\n                generation = generation[0][input_len:]\n                vision_model_response = paligemma_cpu_processor.decode(generation, skip_special_tokens=True)\n        # Unload the PaliGemma CPU model and processor after generating the response\n        return vision_model_response\n    finally:\n        unload_paligemma_cpu_model()\n\n\ndef generate_paligemma(file_path, user_input):\n    try:\n        # Load the PaliGemma model and processor on-demand\n        load_paligemma_model()\n        # Load the saved image using PIL\n        with Image.open(file_path) as img:\n            # Prepare the prompt for the PaliGemma model using the user's question\n            model_inputs = paligemma_processor(text=user_input, images=img, return_tensors=\"pt\").to(\n                f\"cuda:{cuda_device}\")\n            input_len = model_inputs[\"input_ids\"].shape[-1]\n            # Generate the response using the PaliGemma model\n            with torch.inference_mode():\n                generation = paligemma_model.generate(\n                    **model_inputs,\n                    max_new_tokens=100,\n                    do_sample=True  # Set to True for sampling-based generation\n                )\n                generation = generation[0][input_len:]\n                vision_model_response = paligemma_processor.decode(generation, skip_special_tokens=True)\n        # Unload the PaliGemma model and processor after generating the response\n        return vision_model_response\n    finally:\n        unload_paligemma_model()\n\n\ndef generate_phi_vision(file_path, user_input):\n    global cuda_device\n    try:\n        # Load the PhiVision model and processor on-demand\n        load_phi_vision_model()\n        # Load the saved image using PIL\n        with Image.open(file_path) as img:\n            # Prepare the prompt for the PhiVision model\n            messages = [\n                {\"role\": \"user\", \"content\": f\"<|image_1|>\\n{user_input}\"}\n            ]\n            prompt = phiVision_processor.tokenizer.apply_chat_template(\n                messages, tokenize=False, add_generation_prompt=True\n            )\n            # Extract the CUDA_VISIBLE_DEVICES setting from the config file\n            # cuda_devices = config[\"cuda_visible_devices\"]\n            # Convert the CUDA_VISIBLE_DEVICES string to an integer (assuming a single device for simplicity)\n            # cuda_device_index = int(cuda_devices)\n\n            # Prepare the model inputs and move them to the specified CUDA device\n            inputs = phiVision_processor(prompt, [img], return_tensors=\"pt\").to(f\"cuda:{cuda_device}\")\n            # Define the generation arguments\n            generation_args = {\n                \"max_new_tokens\": 500,\n                \"temperature\": 1.0,\n                \"do_sample\": True,  # Set to True for sampling-based generation\n                # \"min_p\": 0.95,  # Optionally set a minimum probability threshold\n            }\n            # Generate the response using the PhiVision model\n            generate_ids = phiVision_model.generate(\n                **inputs,\n                eos_token_id=phiVision_processor.tokenizer.eos_token_id,\n                **generation_args\n            )\n            # Remove input tokens from the generated IDs\n            generate_ids = generate_ids[:, inputs['input_ids'].shape[1]:]\n            # Decode the generated IDs to get the text response\n            vision_model_response = phiVision_processor.batch_decode(\n                generate_ids,\n                skip_special_tokens=True,\n                clean_up_tokenization_spaces=False\n            )[0]\n        # Unload the PhiVision model and processor after generating the response\n        return vision_model_response\n    finally:\n        unload_phi_vision_model()\n\n\ndef generate_deepseek(file_path, user_input):\n    try:\n        load_deepseek_model()\n        conversation = [\n            {\n                \"role\": \"User\",\n                \"content\": f\"<image_placeholder>{user_input}\",\n                \"images\": [f\"{file_path}\"]\n            }, {\n                \"role\": \"Assistant\",\n                \"content\": \"\"\n            }\n        ]\n        print(conversation)\n        pil_images = load_pil_images_for_deepseek(conversation)\n        prepare_inputs = deepseek_processor(\n            conversations=conversation,\n            images=pil_images,\n            force_batchify=True\n        ).to(deepseek_gpt.device)\n        input_embeds = deepseek_gpt.prepare_inputs_embeds(**prepare_inputs)\n        outputs = deepseek_gpt.language_model.generate(\n            inputs_embeds=input_embeds,\n            attention_mask=prepare_inputs.attention_mask,\n            pad_token_id=deepseek_tokenizer.eos_token_id,\n            bos_token_id=deepseek_tokenizer.bos_token_id,\n            eos_token_id=deepseek_tokenizer.eos_token_id,\n            max_new_tokens=512,\n            do_sample=False,\n            use_cache=True\n        )\n        return deepseek_tokenizer.decode(outputs[0].cpu().tolist(), skip_special_tokens=True)\n    finally:\n        unload_deepseek_model()\n\n\ndef generate_bunny(file_path, user_input):\n    global cuda_device\n    try:\n        load_bunny_model()\n        with Image.open(file_path) as image:\n            text = f\"A chat between a curious user and an artificial intelligence assistant. The assistant gives helpful, detailed, and polite answers to the user's questions. USER: <image>\\n{user_input} ASSISTANT:\"\n            text_chunks = [bunny_tokenizer(chunk).input_ids for chunk in text.split('<image>')]\n            input_ids = torch.tensor(text_chunks[0] + [-200] + text_chunks[1][1:], dtype=torch.long).unsqueeze(0).to(\n                f\"cuda:{cuda_device}\")\n            image_tensor = bunny_model.process_images(\n                [image],\n                bunny_model.config\n            ).to(\n                dtype=bunny_model.dtype,\n                device=bunny_model.device\n            )\n            output_ids = bunny_model.generate(\n                input_ids,\n                images=image_tensor,\n                max_new_tokens=896,\n                use_cache=True,\n                repetition_penalty=1.0\n            )[0]\n            return bunny_tokenizer.decode(output_ids[input_ids.shape[1]:], skip_special_tokens=True).strip()\n    finally:\n        unload_bunny_model()\n\n\n# Function to modify the chat history before it is used for text generation\ndef history_modifier(history):\n    # Extract all entries from the \"internal\" history\n    internal_entries = history[\"internal\"]\n    # Iterate over the \"internal\" history entries\n    for internal_index, internal_entry in enumerate(internal_entries):\n        # Extract the text content of the internal entry\n        internal_text = internal_entry[1]\n        # Search for the \"File location\" trigger phrase in the internal text\n        file_location_matches = file_location_pattern.findall(internal_text)\n        if file_location_matches:\n            # Iterate over each match found in the \"internal\" entry\n            for file_path in file_location_matches:\n                # Construct the full match string including the trigger phrase\n                full_match_string = f\"File location: {file_path}\"\n                # Search for the exact same string in the \"visible\" history\n                for visible_entry in history[\"visible\"]:\n                    # Extract the text content of the visible entry\n                    visible_text = visible_entry[1]\n                    # If the \"visible\" entry contains the full match string\n                    if full_match_string in visible_text:\n                        # Split the \"visible\" text at the full match string\n                        _, after_match = visible_text.split(full_match_string, 1)\n                        # Find the position where the \".png\" part ends in the \"internal\" text\n                        png_end_pos = internal_text.find(file_path) + len(file_path)\n                        # If the \".png\" part is found and there is content after it\n                        if png_end_pos < len(internal_text) and internal_text[png_end_pos] == \"\\n\":\n                            # Extract the existing content after the \".png\" part in the \"internal\" text\n                            _ = internal_text[png_end_pos:]\n                            # Replace the existing content after the \".png\" part in the \"internal\" text\n                            # with the corresponding content from the \"visible\" text\n                            new_internal_text = internal_text[:png_end_pos] + after_match\n                            # Update the \"internal\" history entry with the new text\n                            history[\"internal\"][internal_index][1] = new_internal_text\n                        # If there is no content after the \".png\" part in the \"internal\" text,\n                        # append the content from the \"visible\" text directly\n                        else:\n                            # Append the content after the full match string from the \"visible\" text\n                            history[\"internal\"][internal_index][1] += after_match\n    return history\n```\n\nThis is the config file for LucidVision.py:\n```\n{\n    \"image_history_dir\": \"/home/myself/Desktop/OobV115/text-generation-webui/extensions/Lucid_Vision/Image_History/\",\n    \"cuda_visible_devices\": 0,\n    \"default_vision_model\": \"phiVision\",\n    \"phiVision_model_id\": \"/home/myself/Desktop/phiVision/phivisionMay23/Phi-3-vision-128k-instruct/\",\n    \"paligemma_model_id\": \"/home/myself/Desktop/paligemma/paligemmaMay23/paligemma-3b-ft-cococap-448/\",\n    \"paligemma_cpu_model_id\":\"/home/myself/Desktop/paligemma/paligemmaMay23/paligemma-3b-ft-cococap-448/\",\n    \"minicpm_llama3_model_id\": \"/home/myself/Desktop/miniCPM_llava3V/MiniCPM-V-2_6/\",\n    \"deepseek_vl_model_id\": \"/home/myself/Desktop/DeepSeekVL/DeepSeek-VL/deepseek-vl-7b-chat/\",\n    \"bunny_model_id\": \"/home/myself/Desktop/BunnyVision/Bunny-v1_1-Llama-3-8B-V/\",\n    \"got_ocr_model_id\": \"/home/myself/Desktop/GOT_OCR/ModelGOT-OCR2_0/\",\n    \"aria_model_id\": \"/home/myself/Desktop/Aria/\"\n}\n```\n\nPlease pay attention this piece of code called script.py uses both of the GOT-OCR and aria models, use the knowledge from script.py to update the necessary components of LucidVision.py.\n\nPlease write out only the updated or new functions for the LucidVision.py file please.\n\nscript.py\n```\nimport os\n#os.environ[\"CUDA_VISIBLE_DEVICES\"] = \"0\"\nimport gradio as gr\nimport json\nimport pyautogui\nimport screeninfo\nfrom transformers import Owlv2Processor, Owlv2ForObjectDetection, AutoModel, AutoTokenizer, AutoProcessor, PaliGemmaForConditionalGeneration, AutoModelForCausalLM\nfrom PIL import Image, ImageDraw\nimport torch\nimport os\nimport shutil\nimport re  # Import the re module for regular expression operations\nimport json\nimport time\nimport threading\nimport pdf2image  # Add this import for PDF to PNG conversion\nimport uuid\nimport tempfile\nimport time\nimport shutil\nfrom pathlib import Path\nimport time\nimport pypdfium2  # Needs to be at the top to avoid warnings\nimport os\nimport gradio as gr\nimport spaces\nfrom transformers import AutoModel, AutoTokenizer\nfrom PIL import Image\nimport numpy as np\nimport base64\nimport io\nimport uuid\nimport tempfile\nimport subprocess\nimport time\nimport shutil\nfrom pathlib import Path\nos.environ[\"PYTORCH_ENABLE_MPS_FALLBACK\"] = \"1\"  # For some reason, transformers decided to use .isin for a simple op, which is not supported on MPS\nimport gc\nfrom marker.convert import convert_single_pdf\nfrom marker.logger import configure_logging\nfrom marker.models import load_all_models\nfrom marker.output import save_markdown\n\nconfigure_logging()\n\noob_tasks_file = \"extensions/Lucid_Autonomy/oob_tasks.json\"\n\n# Configurable variables\nMONITOR_INDEX = 0  # Index of the monitor to capture (0 for the first monitor, 1 for the second monitor, etc.)\nTEXT_QUERIES = \"colored hyperlink text,clickable icons,text bar field,clickable UI buttons,UI tabs,Interactive UI Elements,blue text hyperlink\"  # Comma-separated text queries for object detection\nSCORE_THRESHOLD = 0.24  # Score threshold for filtering low-probability predictions\nVISION_MODEL_QUESTION = \"Keep your response to less than 5 sentences: What is the text in this image or what does this image describe? The AI is aiding in helping those with visual handicaps so the AI will focus on providing all of the relevant information for the listener.\"\nFULL_IMAGE_VISION_MODEL_QUESTION = \"This is a computer screenshot, identify all article text if the screen is displaying an article.  Describe what you see in this image, if you see UI elements describe them and their general location and if you see text read the text verbatim.  Describe the general theme and context of the image. You are aiding in helping those with visual handicaps so you need to try and focus on providing all of the relevant text on a screen and contextualizing it for the listener.\"\n\n# Use GPU if available\ndevice = 0\n\n# Global variables for models\nowlv2_model = None\nowlv2_processor = None\nminicpm_llama_model = None\nminicpm_llama_tokenizer = None\nchartgemma_model = None\nchartgemma_processor = None\ngot_ocr_model = None\ngot_ocr_tokenizer = None\n\nVISION_MODEL_ID = \"/home/myself/Desktop/miniCPM_llava3V/MiniCPM-V-2_6/\"\nGOT_OCR_MODEL_PATH = '/home/myself/Desktop/GOT_OCR/ModelGOT-OCR2_0/'\n\n# Global variable to store the file path of the selected image\nselected_image_path = None\nselected_markdown_path = None\n\n# Function to set the CUDA_VISIBLE_DEVICES environment variable\ndef set_cuda_visible_devices(device_id):\n    os.environ[\"CUDA_VISIBLE_DEVICES\"] = str(device_id)\n\n# Function to reset the CUDA_VISIBLE_DEVICES environment variable\ndef reset_cuda_visible_devices():\n    os.environ[\"CUDA_VISIBLE_DEVICES\"] = \"\"\n\ndef process_marker_file(filename, output_folder, max_pages=None, start_page=None, langs=None, batch_multiplier=2, ocr_all_pages=False):\n    os.environ[\"CUDA_VISIBLE_DEVICES\"] = \"0\"\n    torch.cuda.set_device(0)  # Explicitly set CUDA device\n    \n    model_lst = load_all_models(device=\"cuda:0\")\n    start = time.time()\n\n    full_text, images, out_meta = convert_single_pdf(filename, model_lst, max_pages=max_pages, langs=langs, batch_multiplier=batch_multiplier, start_page=start_page, ocr_all_pages=ocr_all_pages)\n\n    fname = os.path.basename(filename)\n    subfolder_path = save_markdown(output_folder, fname, full_text, images, out_meta)\n\n    print(f\"Saved markdown to the {subfolder_path} folder\")\n    print(f\"Total time: {time.time() - start}\")\n\n    return subfolder_path\n\ndef generate_image_list(folder_path):\n    \"\"\"\n    Generates a list of image files in the specified folder.\n\n    Args:\n        folder_path (str): The path to the folder containing the image files.\n\n    Returns:\n        list: A list of image file paths.\n    \"\"\"\n    image_list = []\n    for root, dirs, files in os.walk(folder_path):\n        for file in files:\n            if file.endswith(\".png\"):\n                image_list.append(os.path.join(root, file))\n    return image_list\n\ndef match_image_references(md_file_path, image_list):\n    \"\"\"\n    Matches image references in the markdown file with the actual image files.\n\n    Args:\n        md_file_path (str): The path to the markdown file.\n        image_list (list): A list of image file paths.\n\n    Returns:\n        dict: A dictionary mapping image references to their disk locations.\n    \"\"\"\n    image_references = {}\n    with open(md_file_path, 'r') as md_file:\n        content = md_file.read()\n        for image_path in image_list:\n            image_name = os.path.basename(image_path)\n            if image_name in content:\n                image_references[image_name] = image_path\n    return image_references\n\ndef add_disk_location_info(md_file_path, image_references):\n    \"\"\"\n    Adds disk location information and vision model response to the markdown file for each image reference.\n\n    Args:\n        md_file_path (str): The path to the markdown file.\n        image_references (dict): A dictionary mapping image references to their disk locations.\n    \"\"\"\n    with open(md_file_path, 'r') as md_file:\n        content = md_file.read()\n\n        # Load the miniCPM-lama3-v-2_5 model\n        load_minicpm_llama_model()\n\n    for image_name, image_path in image_references.items():\n        # Process the image with the vision model to identify the image type\n        question = \"Identify if this image is a chart, table, equation, graph, bar chart, illustration, drawing, or picture. Respond with either 'illustration', 'graph', 'table', 'chart', 'equation' or 'bar chart'.\"\n\n        # Process the entire screenshot with the minicpm model\n        vision_model_response = process_with_vision_model(image_path, question)\n\n        # Replace the image reference with disk location and vision model response\n        content = content.replace(f\"![{image_name}]({image_name})\", f\"![{image_name}]({image_name})\\n\\nDisk Location: {image_path}\\n\\nInitial Image ID: {vision_model_response}\\n\\n\")\n\n    with open(md_file_path, 'w') as md_file:\n        md_file.write(content)\n\n        # Unload the miniCPM-lama3-v-2_5 model after processing the full image\n        unload_minicpm_llama_model()\n\ndef load_owlv2_model():\n    global owlv2_model, owlv2_processor\n    owlv2_model = Owlv2ForObjectDetection.from_pretrained(\"google/owlv2-base-patch16-ensemble\", trust_remote_code=True).to(device)\n    owlv2_processor = Owlv2Processor.from_pretrained(\"google/owlv2-base-patch16-ensemble\", trust_remote_code=True)\n    print(\"Owlv2 model loaded.\")\n\ndef unload_owlv2_model():\n    global owlv2_model, owlv2_processor\n    if owlv2_model is not None:\n        del owlv2_model\n        del owlv2_processor\n        torch.cuda.empty_cache()\n        print(\"Owlv2 model unloaded.\")\n\ndef load_minicpm_llama_model():\n    global minicpm_llama_model, minicpm_llama_tokenizer\n    if \"int4\" in VISION_MODEL_ID:\n        # Load the 4-bit quantized model and tokenizer\n        minicpm_llama_model = AutoModel.from_pretrained(\n            VISION_MODEL_ID,\n            device_map={\"\": device},\n            trust_remote_code=True,\n            torch_dtype=torch.float16  # Use float16 as per the example code for 4-bit models\n        ).eval()\n        minicpm_llama_tokenizer = AutoTokenizer.from_pretrained(\n            VISION_MODEL_ID,\n            trust_remote_code=True\n        )\n        print(\"MiniCPM-Llama3 4-bit quantized model loaded on-demand.\")\n    else:\n        # Load the standard model and tokenizer\n        minicpm_llama_model = AutoModel.from_pretrained(\n            VISION_MODEL_ID,\n            device_map={\"\": device},  # Use the specified CUDA device\n            trust_remote_code=True,\n            torch_dtype=torch.bfloat16\n        ).eval()\n        minicpm_llama_tokenizer = AutoTokenizer.from_pretrained(\n            VISION_MODEL_ID,\n            trust_remote_code=True\n        )\n        print(\"MiniCPM-Llama3 standard model loaded on-demand.\")\n\ndef unload_minicpm_llama_model():\n    global minicpm_llama_model, minicpm_llama_tokenizer\n    if minicpm_llama_model is not None:\n        del minicpm_llama_model\n        del minicpm_llama_tokenizer\n        torch.cuda.empty_cache()\n        print(\"MiniCPM-Llama3 model unloaded.\")\n\ndef load_chartgemma_model():\n    global chartgemma_model, chartgemma_processor\n    chartgemma_model = PaliGemmaForConditionalGeneration.from_pretrained(\"ahmed-masry/chartgemma\").to(device)\n    chartgemma_processor = AutoProcessor.from_pretrained(\"ahmed-masry/chartgemma\")\n    print(\"ChartGemma model loaded.\")\n\ndef unload_chartgemma_model():\n    global chartgemma_model, chartgemma_processor\n    if chartgemma_model is not None:\n        del chartgemma_model\n        del chartgemma_processor\n        torch.cuda.empty_cache()\n        print(\"ChartGemma model unloaded.\")\n\ndef load_got_ocr_model():\n    global got_ocr_model, got_ocr_tokenizer\n    os.environ[\"CUDA_VISIBLE_DEVICES\"] = \"0\"\n    torch.cuda.set_device(0)  # Explicitly set CUDA device\n    \n\n    got_ocr_model = AutoModel.from_pretrained(GOT_OCR_MODEL_PATH, trust_remote_code=True, low_cpu_mem_usage=True, device_map='cuda:0', use_safetensors=True).eval().cuda()\n    got_ocr_tokenizer = AutoTokenizer.from_pretrained(GOT_OCR_MODEL_PATH, trust_remote_code=True)\n    print(\"GOT-OCR model loaded.\")\n\ndef unload_got_ocr_model():\n    global got_ocr_model, got_ocr_tokenizer\n    if got_ocr_model is not None:\n        del got_ocr_model\n        del got_ocr_tokenizer\n        torch.cuda.empty_cache()\n        print(\"GOT-OCR model unloaded.\")\n\ndef take_screenshot(monitor_index, text_queries, score_threshold, vision_model_question, full_image_vision_model_question, output_filename=\"screenshot.png\"):\n    \"\"\"\n    Takes a screenshot of a specific monitor in a multi-monitor setup.\n\n    Args:\n        monitor_index (int): The index of the monitor to capture.\n        text_queries (str): Comma-separated text queries for object detection.\n        score_threshold (float): The score threshold for filtering low-probability predictions.\n        vision_model_question (str): The question to ask the vision model for cropped images.\n        full_image_vision_model_question (str): The question to ask the vision model for the full image.\n        output_filename (str): The filename to save the screenshot as (default is \"screenshot.png\").\n    \"\"\"\n    monitor_index = int(monitor_index)\n    score_threshold = float(score_threshold)\n\n    # Get information about all monitors\n    monitors = screeninfo.get_monitors()\n\n    if monitor_index >= len(monitors):\n        raise ValueError(f\"Monitor index {monitor_index} is out of range. There are only {len(monitors)} monitors.\")\n\n    # Get the region of the specified monitor\n    monitor = monitors[monitor_index]\n    region = (monitor.x, monitor.y, monitor.width, monitor.height)\n\n    # Take the screenshot\n    output_dir = \"extensions/Lucid_Autonomy\"\n    os.makedirs(output_dir, exist_ok=True)\n    screenshot_path = os.path.join(output_dir, output_filename)\n    screenshot = pyautogui.screenshot(region=region)\n    screenshot.save(screenshot_path)\n    print(f\"Screenshot saved as {screenshot_path}\")\n\n    # Process the image using the Owlv2 model\n    annotated_image_path, human_annotated_image_path, json_output_path = query_image(screenshot_path, text_queries, score_threshold)\n\n    # Load the miniCPM-lama3-v-2_5 model\n    load_minicpm_llama_model()\n\n    # Process the entire screenshot with the minicpm model\n    full_image_response = process_with_vision_model(annotated_image_path, full_image_vision_model_question)\n\n    # Unload the miniCPM-lama3-v-2_5 model after processing the full image\n    unload_minicpm_llama_model()\n\n    # Create the output directory if it doesn't exist\n    output_dir = \"extensions/Lucid_Autonomy/ImageOutputTest\"\n    os.makedirs(output_dir, exist_ok=True)\n\n    # Clear the output directory\n    for filename in os.listdir(output_dir):\n        file_path = os.path.join(output_dir, filename)\n        try:\n            if os.path.isfile(file_path) or os.path.islink(file_path):\n                os.unlink(file_path)\n            elif os.path.isdir(file_path):\n                shutil.rmtree(file_path)\n        except Exception as e:\n            print(f\"Failed to delete {file_path}. Reason: {e}\")\n\n    # Crop the detected objects and save them to the output directory\n    crop_images(annotated_image_path, json_output_path, output_dir, full_image_response)\n\n    print(\"Processing complete. Check the output directory for the cropped images and results.\")\n\ndef query_image(img_path, text_queries, score_threshold):\n    \"\"\"\n    Processes the image using the Owlv2 model to detect objects based on text queries.\n\n    Args:\n        img_path (str): The path to the input image.\n        text_queries (str): Comma-separated text queries for object detection.\n        score_threshold (float): The score threshold for filtering low-probability predictions.\n    \"\"\"\n    load_owlv2_model()\n\n    img = Image.open(img_path)\n    text_queries = text_queries.split(\",\")\n\n    size = max(img.size)\n    target_sizes = torch.Tensor([[size, size]])\n    inputs = owlv2_processor(text=text_queries, images=img, return_tensors=\"pt\").to(device)\n\n    with torch.no_grad():\n        outputs = owlv2_model(**inputs)\n\n    outputs.logits = outputs.logits.cpu()\n    outputs.pred_boxes = outputs.pred_boxes.cpu()\n    results = owlv2_processor.post_process_object_detection(outputs=outputs, target_sizes=target_sizes)\n    boxes, scores, labels = results[0][\"boxes\"], results[0][\"scores\"], results[0][\"labels\"]\n\n    result_labels = []\n    img_pil = img.copy()\n    draw = ImageDraw.Draw(img_pil)\n\n    human_img_pil = img.copy()\n    human_draw = ImageDraw.Draw(human_img_pil)\n\n    for box, score, label in zip(boxes, scores, labels):\n        box = [int(i) for i in box.tolist()]\n        if score < score_threshold:\n            continue\n        result_labels.append([box, text_queries[label.item()]])\n        # Do not draw the text label within the bounding box\n        # draw.text((box[0], box[1]), text_queries[label.item()], fill=\"red\")\n\n        # Draw the boxes for the human-annotated image\n        human_draw.rectangle(box, outline=\"red\", width=2)\n\n    # Save the annotated image for debugging\n    annotated_image_path = \"extensions/Lucid_Autonomy/screenshot.png\"\n    img_pil.save(annotated_image_path)\n\n    # Save the human-annotated image for human inspection\n    human_annotated_image_path = \"extensions/Lucid_Autonomy/Human_annotated_image.png\"\n    human_img_pil.save(human_annotated_image_path)\n\n    # Save the JSON output to a file\n    json_output_path = \"extensions/Lucid_Autonomy/output.json\"\n    with open(json_output_path, 'w') as f:\n        json.dump(result_labels, f)\n\n    unload_owlv2_model()\n\n    return annotated_image_path, human_annotated_image_path, json_output_path\n\ndef crop_images(image_path, json_output_path, output_dir=\"extensions/Lucid_Autonomy/ImageOutputTest\", full_image_response=\"\"):\n    \"\"\"\n    Crops out the detected objects from the input image based on the bounding box coordinates.\n\n    Args:\n        image_path (str): The path to the input image.\n        json_output_path (str): The path to the JSON file containing the bounding box coordinates.\n        output_dir (str): The directory to save the cropped images (default is \"extensions/Lucid_Autonomy/ImageOutputTest\").\n        full_image_response (str): The response from the vision model for the full image.\n    \"\"\"\n    with open(json_output_path, 'r') as f:\n        data = json.load(f)\n\n    img = Image.open(image_path)\n\n    results = []\n\n    # Load the miniCPM-lama3-v-2_5 model once before processing the images\n    load_minicpm_llama_model()\n\n    for i, item in enumerate(data):\n        box = item[0]\n        label = item[1]\n        cropped_img = img.crop(box)\n        cropped_img_path = f\"{output_dir}/{label}_{i}.png\"\n        cropped_img.save(cropped_img_path)\n\n        # Process the cropped image with the miniCPM-lama3-v-2_5 model\n        vision_model_response = process_with_vision_model(cropped_img_path, VISION_MODEL_QUESTION)\n\n        # Store the results in a structured format\n        results.append({\n            \"image_name\": f\"{label}_{i}.png\",\n            \"coordinates\": box,\n            \"description\": vision_model_response,\n            \"children\": []\n        })\n\n    # Unload the miniCPM-lama3-v-2_5 model after processing all images\n    unload_minicpm_llama_model()\n\n    # Determine parent-child relationships\n    for i, result in enumerate(results):\n        for j, other_result in enumerate(results):\n            if i != j:\n                box1 = result[\"coordinates\"]\n                box2 = other_result[\"coordinates\"]\n                center_x1 = (box1[0] + box1[2]) // 2\n                center_y1 = (box1[1] + box1[3]) // 2\n                if box2[0] <= center_x1 <= box2[2] and box2[1] <= center_y1 <= box2[3]:\n                    other_result[\"children\"].append(result[\"image_name\"])\n\n    # Save the results to a JSON file\n    results_json_path = f\"{output_dir}/results.json\"\n    with open(results_json_path, 'w') as f:\n        json.dump(results, f, indent=4)\n\n    # Add the full image response to the results\n    if full_image_response:\n        results.append({\n            \"image_name\": \"full_image.png\",\n            \"coordinates\": [],\n            \"description\": full_image_response,\n            \"children\": []\n        })\n\n        # Save the updated results to the JSON file\n        with open(results_json_path, 'w') as f:\n            json.dump(results, f, indent=4)\n\ndef process_with_vision_model(image_path, question):\n    \"\"\"\n    Processes the image with the miniCPM-lama3-v-2_5 model and returns the response.\n\n    Args:\n        image_path (str): The path to the input image.\n        question (str): The question to ask the vision model.\n\n    Returns:\n        str: The response from the vision model.\n    \"\"\"\n    image = Image.open(image_path).convert(\"RGB\")\n    messages = [\n        {\"role\": \"user\", \"content\": f\"{question}\"}\n    ]\n    # Define the generation arguments\n    generation_args = {\n        \"max_new_tokens\": 1024,\n        \"repetition_penalty\": 1.05,\n        \"num_beams\": 3,\n        \"top_p\": 0.9,\n        \"top_k\": 1,\n        \"temperature\": 0.1,\n        \"sampling\": True,\n    }\n    if \"int4\" in VISION_MODEL_ID:\n        # Disable streaming for the 4-bit model\n        generation_args[\"stream\"] = False\n        # Use the model.chat method with streaming enabled\n        vision_model_response = \"\"\n        for new_text in minicpm_llama_model.chat(\n                image=image,\n                msgs=messages,\n                tokenizer=minicpm_llama_tokenizer,\n                **generation_args\n        ):\n            vision_model_response += new_text\n            print(new_text, flush=True, end='')\n\n    else:\n        minicpm_llama_model.to(device)\n        vision_model_response = minicpm_llama_model.chat(\n            image=image,\n            msgs=messages,\n            tokenizer=minicpm_llama_tokenizer,\n            **generation_args\n        )\n    return vision_model_response\n\ndef process_with_chartgemma_model(image_path, question):\n    \"\"\"\n    Processes the image with the ChartGemma model and returns the response.\n\n    Args:\n        image_path (str): The path to the input image.\n        question (str): The question to ask the vision model.\n\n    Returns:\n        str: The response from the vision model.\n    \"\"\"\n    image = Image.open(image_path).convert(\"RGB\")\n    inputs = chartgemma_processor(text=question, images=image, return_tensors=\"pt\")\n    inputs = {k: v.to(device) for k, v in inputs.items()}\n\n    prompt_length = inputs['input_ids'].shape[1]\n\n    # Generate\n    generate_ids = chartgemma_model.generate(**inputs, max_new_tokens=512)\n    output_text = chartgemma_processor.batch_decode(generate_ids[:, prompt_length:], skip_special_tokens=True, clean_up_tokenization_spaces=False)[0]\n\n    return output_text\n\ndef convert_pdf_to_png(pdf_path, output_folder):\n    \"\"\"\n    Converts each page of the input PDF to a PNG file and saves them in the specified output folder.\n\n    Args:\n        pdf_path (str): The path to the input PDF file.\n        output_folder (str): The path to the output folder where the PNG files will be saved.\n    \"\"\"\n    os.makedirs(output_folder, exist_ok=True)\n    images = pdf2image.convert_from_path(pdf_path)\n    for i, image in enumerate(images):\n        image.save(os.path.join(output_folder, f\"page_{i+1}.png\"), \"PNG\")\n\n# Define the base directories\nBASE_UPLOAD_FOLDER = \"extensions/Lucid_Autonomy/MarkerOutput\"\nBASE_RESULTS_FOLDER = \"extensions/Lucid_Autonomy/MarkerOutput\"\n\ndef run_got_ocr(image_path, got_mode, fine_grained_mode=\"\", ocr_color=\"\", ocr_box=\"\"):\n    # Extract the PDF name from the image path\n    pdf_name = os.path.basename(os.path.dirname(image_path))\n\n    # Define the upload and results folders based on the PDF name\n    UPLOAD_FOLDER = os.path.join(BASE_UPLOAD_FOLDER, pdf_name)\n    RESULTS_FOLDER = os.path.join(BASE_RESULTS_FOLDER, pdf_name)\n\n    # Ensure the directories exist\n    os.makedirs(UPLOAD_FOLDER, exist_ok=True)\n    os.makedirs(RESULTS_FOLDER, exist_ok=True)\n\n    unique_id = str(uuid.uuid4())\n    temp_image_path = os.path.join(UPLOAD_FOLDER, f\"{unique_id}.png\")\n    result_path = os.path.join(RESULTS_FOLDER, f\"{unique_id}.html\")\n\n    shutil.copy(image_path, temp_image_path)\n\n    try:\n        if got_mode == \"plain texts OCR\":\n            res = got_ocr_model.chat(got_ocr_tokenizer, temp_image_path, ocr_type='ocr')\n            return res, None\n        elif got_mode == \"format texts OCR\":\n            res = got_ocr_model.chat(got_ocr_tokenizer, temp_image_path, ocr_type='format', render=True, save_render_file=result_path)\n        elif got_mode == \"plain multi-crop OCR\":\n            res = got_ocr_model.chat_crop(got_ocr_tokenizer, temp_image_path, ocr_type='ocr')\n            return res, None\n        elif got_mode == \"format multi-crop OCR\":\n            res = got_ocr_model.chat_crop(got_ocr_tokenizer, temp_image_path, ocr_type='format', render=True, save_render_file=result_path)\n        elif got_mode == \"plain fine-grained OCR\":\n            res = got_ocr_model.chat(got_ocr_tokenizer, temp_image_path, ocr_type='ocr', ocr_box=ocr_box, ocr_color=ocr_color)\n            return res, None\n        elif got_mode == \"format fine-grained OCR\":\n            res = got_ocr_model.chat(got_ocr_tokenizer, temp_image_path, ocr_type='format', ocr_box=ocr_box, ocr_color=ocr_color, render=True, save_render_file=result_path)\n\n        res_markdown = res\n\n        if \"format\" in got_mode and os.path.exists(result_path):\n            with open(result_path, 'r') as f:\n                html_content = f.read()\n            encoded_html = base64.b64encode(html_content.encode('utf-8')).decode('utf-8')\n            iframe_src = f\"data:text/html;base64,{encoded_html}\"\n            iframe = f'<iframe src=\"{iframe_src}\" width=\"100%\" height=\"600px\"></iframe>'\n            download_link = f'<a href=\"data:text/html;base64,{encoded_html}\" download=\"result_{unique_id}.html\">Download Full Result</a>'\n            return res_markdown, f\"{download_link}<br>{iframe}\"\n        else:\n            return res_markdown, None\n    except Exception as e:\n        return f\"Error: {str(e)}\", None\n    finally:\n        if os.path.exists(temp_image_path):\n            os.remove(temp_image_path)\n\n\ndef compare_and_merge_texts(file1_path, file2_path, group_size, output_path):\n    # Read and clean both files\n    with open(file1_path, 'r') as f1, open(file2_path, 'r') as f2:\n        text1 = clean_text_doc2(f1.read())\n        text2 = clean_text_doc2(f2.read())\n\n    # Get word groups (case-insensitive for comparison)\n    groups1 = [group.lower() for group in get_word_groups(text1, group_size)]\n    groups2 = [group.lower() for group in get_word_groups(text2, group_size)]\n\n    # Find common groups\n    common_groups = set(groups1) & set(groups2)\n\n    # Remove common groups from text1 (case-sensitive removal)\n    for group in common_groups:\n        text1 = re.sub(re.escape(group), '', text1, flags=re.IGNORECASE)\n\n    # Merge unique parts of text1 into text2\n    merged_text = text2 + ' ' + text1.strip()\n\n    # Write the result to the output file\n    with open(output_path, 'w') as f_out:\n        f_out.write(merged_text)\n\n    print(f\"Merged text has been written to {output_path}\")\n\ndef clean_text_doc2(text):\n    # Preserve all special characters, punctuation, and capitalization...just dont ahhah\n    return text\n\ndef get_word_groups(text, group_size):\n    words = re.findall(r'\\S+', text)\n    return [' '.join(words[i:i+group_size]) for i in range(len(words) - group_size + 1)]\n\n# Global variables for Gradio inputs\nglobal_vars = {\n    \"global_monitor_index\": \"global_monitor_index\",\n    \"global_text_queries\": TEXT_QUERIES,\n    \"global_score_threshold\": SCORE_THRESHOLD,\n    \"global_vision_model_question\": VISION_MODEL_QUESTION,\n    \"global_full_image_vision_model_question\": FULL_IMAGE_VISION_MODEL_QUESTION\n}\n\ndef ui():\n    \"\"\"\n    Creates custom gradio elements when the UI is launched.\n    \"\"\"\n    with gr.Blocks() as demo:\n        with gr.Row():\n            with gr.Column():\n                monitor_index = gr.Textbox(label=\"Monitor Index\", value=str(MONITOR_INDEX))\n                text_queries = gr.Textbox(label=\"Text Queries\", value=TEXT_QUERIES)\n                score_threshold = gr.Textbox(label=\"Score Threshold\", value=str(SCORE_THRESHOLD))\n                vision_model_question = gr.Textbox(label=\"Vision Model Question\", value=VISION_MODEL_QUESTION)\n                full_image_vision_model_question = gr.Textbox(label=\"Full Image Vision Model Question\", value=FULL_IMAGE_VISION_MODEL_QUESTION)\n                take_screenshot_button = gr.Button(value=\"Take Screenshot\")\n                process_screenshot_button = gr.Button(value=\"Process Screenshot With GOT-OCR\")\n\n                # File upload component\n                file_upload = gr.File(label=\"Upload PDF File\")\n\n                # Radio checkbox for GOT-OCR\n                use_got_ocr = gr.Checkbox(label=\"Use GOT-OCR\", value=False)\n\n                # Text box for group_size\n                group_size = gr.Textbox(label=\"Group Size\", value=\"5\")\n\n                # Checkbox for using results.json\n                use_results_json = gr.Checkbox(label=\"Use results.json\", value=True)\n\n                # Button to clear results.json\n                clear_results_button = gr.Button(value=\"Clear results.json\")\n\n                # New button to unload all models\n                unload_models_button = gr.Button(value=\"Unload All Models\")\n\n        # Update global variables when the user changes the input fields\n        monitor_index.change(lambda x: global_vars.update({\"global_monitor_index\": int(x)}), inputs=monitor_index, outputs=None)\n        text_queries.change(lambda x: global_vars.update({\"global_text_queries\": x}), inputs=text_queries, outputs=None)\n        score_threshold.change(lambda x: global_vars.update({\"global_score_threshold\": float(x)}), inputs=score_threshold, outputs=None)\n        vision_model_question.change(lambda x: global_vars.update({\"global_vision_model_question\": x}), inputs=vision_model_question, outputs=None)\n        full_image_vision_model_question.change(lambda x: global_vars.update({\"global_full_image_vision_model_question\": x}), inputs=full_image_vision_model_question, outputs=None)\n\n        take_screenshot_button.click(\n            fn=take_screenshot,\n            inputs=[monitor_index, text_queries, score_threshold, vision_model_question, full_image_vision_model_question],\n            outputs=None\n        )\n\n        process_screenshot_button.click(\n            fn=process_screenshot_with_got_ocr,\n            inputs=[monitor_index],\n            outputs=None\n        )\n\n        # Handle file upload event\n        file_upload.upload(\n            fn=handle_file_upload_and_copy,\n            inputs=[file_upload, use_got_ocr, group_size],\n            outputs=None\n        )\n\n        # Add the checkbox state to the global variables\n        use_results_json.change(lambda x: global_vars.update({\"use_results_json\": x}), inputs=use_results_json, outputs=None)\n\n        # Handle clear results.json button click\n        clear_results_button.click(\n            fn=clear_results_json,\n            inputs=None,\n            outputs=None\n        )\n\n        # Click event handler for the new button\n        unload_models_button.click(\n            fn=unload_all_models,\n            inputs=None,\n            outputs=None\n        )\n\n    return demo\n\ndef handle_file_upload_and_copy(file, use_got_ocr, group_size):\n    \"\"\"\n    Handles the file upload event and creates a copy of the PDF.\n    \"\"\"\n    if file is not None:\n        file_path = file.name\n        output_folder = \"extensions/Lucid_Autonomy/MarkerOutput\"\n        os.makedirs(output_folder, exist_ok=True)\n\n        # Create a subfolder with the same name as the PDF\n        pdf_name = os.path.splitext(os.path.basename(file_path))[0]\n        pdf_subfolder = os.path.join(output_folder, pdf_name)\n        os.makedirs(pdf_subfolder, exist_ok=True)\n\n        # Copy the uploaded PDF to the subfolder\n        pdf_copy_path = os.path.join(pdf_subfolder, os.path.basename(file_path))\n        shutil.copy2(file_path, pdf_copy_path)\n        print(f\"Created a copy of the PDF: {pdf_copy_path}\")\n\n        # Continue with the rest of the file processing\n        handle_file_upload(file, use_got_ocr, group_size)\n\n# Define the function to unload all models\ndef unload_all_models():\n    unload_owlv2_model()\n    unload_minicpm_llama_model()\n    unload_chartgemma_model()\n    unload_got_ocr_model()\n    torch.cuda.empty_cache()\n    print(\"All models unloaded.\")\n\n\n\n# Define the function to process the screenshot with GOT-OCR\ndef process_screenshot_with_got_ocr(monitor_index):\n    monitor_index = int(monitor_index)\n\n    # Get information about all monitors\n    monitors = screeninfo.get_monitors()\n\n    if monitor_index >= len(monitors):\n        raise ValueError(f\"Monitor index {monitor_index} is out of range. There are only {len(monitors)} monitors.\")\n\n    # Get the region of the specified monitor\n    monitor = monitors[monitor_index]\n    region = (monitor.x, monitor.y, monitor.width, monitor.height)\n\n    # Take the screenshot\n    output_dir = \"extensions/Lucid_Autonomy\"\n    os.makedirs(output_dir, exist_ok=True)\n    output_filename = \"screenshot.png\"\n    screenshot_path = os.path.join(output_dir, output_filename)\n    screenshot = pyautogui.screenshot(region=region)\n    screenshot.save(screenshot_path)\n    print(f\"Screenshot saved as {screenshot_path}\")\n\n    # Load the GOT-OCR model\n    load_got_ocr_model()\n    print(\"GOT-OCR model loaded.\")\n\n    # Process the screenshot with GOT-OCR\n    got_ocr_result, _ = run_got_ocr(screenshot_path, got_mode=\"plain texts OCR\")\n    print(f\"GOT-OCR result: {got_ocr_result}\")\n\n    # Save the GOT-OCR result to results.json\n    results_json_path = \"extensions/Lucid_Autonomy/ImageOutputTest/results.json\"\n    with open(results_json_path, 'w') as f:\n        json.dump([{\"image_name\": \"screenshot.png\", \"description\": got_ocr_result}], f, indent=4)\n\n    # Unload the GOT-OCR model\n    unload_got_ocr_model()\n    print(\"GOT-OCR model unloaded.\")\n\n    print(\"Screenshot processed with GOT-OCR and results saved to results.json\")\n\n\n\n\n\n\n# Function to clear the results.json file\ndef clear_results_json():\n    \"\"\"\n    Clears the contents of the results.json file and replaces it with an empty list.\n    \"\"\"\n    results_json_path = \"extensions/Lucid_Autonomy/ImageOutputTest/results.json\"\n    with open(results_json_path, 'w') as f:\n        json.dump([], f)\n    print(f\"Cleared the contents of {results_json_path}\")\n\n\ndef handle_file_upload(file, use_got_ocr, group_size):\n    \"\"\"\n    Handles the file upload event.\n    \"\"\"\n    global selected_image_path\n    global selected_markdown_path\n    if file is not None:\n        file_path = file.name\n        output_folder = \"extensions/Lucid_Autonomy/MarkerOutput\"\n        os.makedirs(output_folder, exist_ok=True)\n\n        # Convert PDF to PNG\n        png_output_folder = os.path.join(output_folder, os.path.splitext(os.path.basename(file_path))[0])\n        os.makedirs(png_output_folder, exist_ok=True)\n        convert_pdf_to_png(file_path, png_output_folder)\n\n        if use_got_ocr:\n            \n\n            # Process the PDF with Marker\n\n            \n            process_marker_file(file_path, output_folder)\n            print(f\"Processed file: {file_path}\")\n\n            # Generate a list of images\n            image_list = generate_image_list(output_folder)\n\n            # Locate the markdown file within the subfolder\n            pdf_name = os.path.splitext(os.path.basename(file_path))[0]\n            md_file_path = os.path.join(output_folder, pdf_name, f\"{pdf_name}.md\")\n\n            # Match image references in the markdown file\n            image_references = match_image_references(md_file_path, image_list)\n\n            # Add disk location information and vision model response to the markdown file\n            add_disk_location_info(md_file_path, image_references)\n\n            print(f\"Updated markdown file with disk location information and vision model response: {md_file_path}\")\n            \n            # Load GOT-OCR model\n            load_got_ocr_model()\n\n            # Process each PNG file with GOT-OCR, only selecting files with the format \"page_#.png\"\n            png_files = [os.path.join(png_output_folder, f) for f in os.listdir(png_output_folder) if re.match(r'^page_\\d+\\.png$', f)]\n\n            # Sort the PNG files based on the page number\n            png_files.sort(key=lambda x: int(re.search(r'page_(\\d+)\\.png', os.path.basename(x)).group(1)))\n\n\n            got_ocr_results = []\n            for png_file in png_files:\n                got_ocr_result, _ = run_got_ocr(png_file, got_mode=\"format texts OCR\")\n                got_ocr_results.append(got_ocr_result)\n\n            # Unload GOT-OCR model\n            unload_got_ocr_model()\n\n            # Stitch GOT-OCR outputs into a single markdown file\n            got_ocr_output_path = os.path.join(png_output_folder, \"got_ocr_output.md\")\n            with open(got_ocr_output_path, 'w') as f_out:\n                for result in got_ocr_results:\n                    f_out.write(result + \"\\n\\n\")\n\n            # Merge GOT-OCR output with Marker output\n            compare_and_merge_texts(got_ocr_output_path, md_file_path, group_size=int(group_size), output_path=md_file_path)\n\n            # Set the global variable for the selected image path\n            selected_image_path = md_file_path\n            selected_markdown_path = md_file_path\n        else:\n            # Process the PDF with Marker without GOT-OCR\n            process_marker_file(file_path, output_folder)\n            print(f\"Processed file: {file_path}\")\n\n            # Generate a list of images\n            image_list = generate_image_list(output_folder)\n\n            # Locate the markdown file within the subfolder\n            pdf_name = os.path.splitext(os.path.basename(file_path))[0]\n            md_file_path = os.path.join(output_folder, pdf_name, f\"{pdf_name}.md\")\n\n            # Match image references in the markdown file\n            image_references = match_image_references(md_file_path, image_list)\n\n            # Add disk location information and vision model response to the markdown file\n            add_disk_location_info(md_file_path, image_references)\n\n            print(f\"Updated markdown file with disk location information and vision model response: {md_file_path}\")\n\n            # Set the global variable for the selected image path\n            selected_image_path = md_file_path\n            selected_markdown_path = md_file_path\n\n\n\n# Modify the input_modifier function\ndef input_modifier(user_input, state):\n    \"\"\"\n    Modifies the user input before it is processed by the LLM.\n    \"\"\"\n    global selected_image_path\n    global selected_markdown_path\n\n    # Check if a markdown file has been selected and stored in the global variable\n    if selected_markdown_path:\n        # Read the contents of the markdown file\n        with open(selected_markdown_path, 'r') as md_file:\n            markdown_content = md_file.read()\n\n        # Construct the message with the markdown content\n        combined_input = f\"{user_input}\\n\\n{markdown_content}\"\n\n        # Reset the selected markdown path to None after processing\n        selected_markdown_path = None\n        return combined_input\n\n    # If no markdown file is selected, return the user input as is\n    return user_input\n\naria_model = None\naria_processor = None\n\ndef load_aria_model():\n    global aria_model, aria_processor\n    if aria_model is None:\n        print(\"Loading ARIA model...\")\n        aria_model = AutoModelForCausalLM.from_pretrained(\n            \"/home/myself/Desktop/Aria/\",\n            device_map=\"auto\",\n            torch_dtype=torch.bfloat16,\n            trust_remote_code=True\n        )\n        aria_processor = AutoProcessor.from_pretrained(\n            \"/home/myself/Desktop/Aria/\",\n            trust_remote_code=True\n        )\n        print(\"ARIA model loaded successfully.\")\n    else:\n        print(\"ARIA model already loaded.\")\n\ndef unload_aria_model():\n    global aria_model, aria_processor\n    if aria_model is not None:\n        print(\"Unloading ARIA model...\")\n        # Move model to CPU before deletion\n        aria_model.cpu()\n        # Delete the model and processor\n        del aria_model\n        del aria_processor\n        # Set to None to indicate they're unloaded\n        aria_model = None\n        aria_processor = None\n        # Clear CUDA cache\n        if torch.cuda.is_available():\n            torch.cuda.empty_cache()\n        # Run garbage collection\n        gc.collect()\n        print(\"ARIA model unloaded successfully.\")\n    else:\n        print(\"ARIA model not loaded, nothing to unload.\")\n    \n    # Print current GPU memory usage\n    if torch.cuda.is_available():\n        print(f\"Current GPU memory allocated: {torch.cuda.memory_allocated() / 1e9:.2f} GB\")\n        print(f\"Current GPU memory reserved: {torch.cuda.memory_reserved() / 1e9:.2f} GB\")\n\ndef process_with_aria_model(image_path, question):\n    global aria_model, aria_processor\n    \n    if aria_model is None:\n        load_aria_model()\n    \n    print(\"Processing image with ARIA model...\")\n    image = Image.open(image_path).convert(\"RGB\")\n    messages = [\n        {\"role\": \"user\", \"content\": [\n            {\"text\": None, \"type\": \"image\"},\n            {\"text\": question, \"type\": \"text\"},\n        ]}\n    ]\n    \n    text = aria_processor.apply_chat_template(messages, add_generation_prompt=True)\n    inputs = aria_processor(text=text, images=image, return_tensors=\"pt\")\n    inputs[\"pixel_values\"] = inputs[\"pixel_values\"].to(aria_model.dtype)\n    inputs = {k: v.to(aria_model.device) for k, v in inputs.items()}\n\n    with torch.inference_mode(), torch.cuda.amp.autocast(dtype=torch.bfloat16):\n        output = aria_model.generate(\n            **inputs,\n            max_new_tokens=1024,\n            stop_strings=[\"<|im_end|>\"],\n            tokenizer=aria_processor.tokenizer,\n            do_sample=True,\n            temperature=0.9,\n        )\n        output_ids = output[0][inputs[\"input_ids\"].shape[1]:]\n        result = aria_processor.decode(output_ids, skip_special_tokens=True)\n\n    print(\"Image processing complete.\")\n    return result\n\n# Modify the output_modifier function to handle the new trigger phrase\ndef output_modifier(output, state):\n    \"\"\"\n    Modifies the LLM output before it is presented in the UI.\n    \"\"\"\n    global oob_tasks\n\n    # Search for the \"Autonomy_Tasks:\" trigger phrase in the LLM's output\n    if \"Autonomy_Tasks:\" in output:\n        # Clean the chat history\n        state[\"history\"] = history_modifier(state[\"history\"])\n        # Extract tasks and execute them\n        tasks_section = output.split(\"Autonomy_Tasks:\")[-1].strip()\n        if tasks_section:\n            # Write OOB tasks to a JSON file\n            with open(oob_tasks_file, 'w') as f:\n                json.dump(tasks_section.split(\"\\n\"), f)\n\n            # Trigger the execution of OOB tasks after a delay\n            threading.Thread(target=execute_oob_tasks_with_delay).start()\n\n    # Search for the \"Image_File_Location:\" trigger phrase in the LLM's output\n    file_location_matches = re.findall(r\"Image_File_Location: (.+)$\", output, re.MULTILINE)\n    if file_location_matches:\n        # Extract the first match (assuming only one file location per output)\n        file_path = file_location_matches[0]\n        # Extract the questions for the vision model\n        questions_section, _ = output.split(f\"Image_File_Location: {file_path}\", 1)\n        # Remove all newlines from the questions section and replace them with spaces\n        questions = \" \".join(questions_section.strip().splitlines())\n\n        # Initialize an empty response string\n        vision_model_response = \"\"\n\n        load_minicpm_llama_model()\n        # Process the image with the MiniCPM model\n        vision_model_response = process_with_vision_model(file_path, questions)\n        unload_minicpm_llama_model()\n\n        # Format the image path for inline display\n        relative_path = file_path.split(\"extensions/\")[-1]\n        formatted_image_path = f\"<img src=\\\"/file/extensions/{relative_path}\\\">\"\n\n        # Append the vision model's responses and the formatted image path to the output\n        output_with_responses = f\"{output}\\n\\nVision Model Responses:\\n{vision_model_response}\\n\\n{formatted_image_path}\"\n        return output_with_responses\n\n    # Search for the \"Data_File_Location:\" trigger phrase in the LLM's output\n    data_file_location_matches = re.findall(r\"Data_File_Location: (.+)$\", output, re.MULTILINE)\n    if data_file_location_matches:\n        # Extract the first match (assuming only one file location per output)\n        file_path = data_file_location_matches[0]\n        # Extract the questions for the vision model\n        questions_section, _ = output.split(f\"Data_File_Location: {file_path}\", 1)\n        # Remove all newlines from the questions section and replace them with spaces\n        questions = \" \".join(questions_section.strip().splitlines())\n\n        # Initialize an empty response string\n        vision_model_response = \"\"\n\n        load_chartgemma_model()\n        # Process the image with the ChartGemma model\n        vision_model_response = process_with_chartgemma_model(file_path, questions)\n        unload_chartgemma_model()\n\n        # Format the image path for inline display\n        relative_path = file_path.split(\"extensions/\")[-1]\n        formatted_image_path = f\"<img src=\\\"/file/extensions/{relative_path}\\\">\"\n\n        # Append the vision model's responses and the formatted image path to the output\n        output_with_responses = f\"{output}\\n\\nVision Model Responses:\\n{vision_model_response}\\n\\n{formatted_image_path}\"\n        return output_with_responses\n\n    # Search for the \"ARIA_File_Location:\" trigger phrase in the LLM's output\n    aria_file_location_matches = re.findall(r\"ARIA_File_Location: (.+)$\", output, re.MULTILINE)\n    if aria_file_location_matches:\n        # Extract the first match (assuming only one file location per output)\n        file_path = aria_file_location_matches[0]\n        # Extract the questions for the vision model\n        questions_section, _ = output.split(f\"ARIA_File_Location: {file_path}\", 1)\n        # Remove all newlines from the questions section and replace them with spaces\n        questions = \" \".join(questions_section.strip().splitlines())\n\n        # Initialize an empty response string\n        vision_model_response = \"\"\n\n        load_aria_model()\n        # Process the image with the ARIA model\n        vision_model_response = process_with_aria_model(file_path, questions)\n        unload_aria_model()\n\n        # Format the image path for inline display\n        relative_path = file_path.split(\"extensions/\")[-1]\n        formatted_image_path = f\"<img src=\\\"/file/extensions/{relative_path}\\\">\"\n\n        # Append the vision model's responses and the formatted image path to the output\n        output_with_responses = f\"{output}\\n\\nVision Model Responses:\\n{vision_model_response}\\n\\n{formatted_image_path}\"\n        return output_with_responses\n\n    # If no file location is found, return the output as is\n    return output\n\n\noob_tasks = []\n\ndef execute_oob_tasks(tasks_section):\n    \"\"\"\n    Executes the OOB tasks listed in the tasks_section.\n    \"\"\"\n    global oob_tasks\n    tasks = tasks_section\n    for task in tasks:\n        task = task.strip()\n        if task.startswith(\"OOB_MouseMover =\"):\n            image_name = task.split(\"=\")[1].strip()\n            move_mouse_to_image(image_name)\n        elif task.startswith(\"OOB_MouseClick =\"):\n            value = task.split(\"=\")[1].strip()\n            if \",\" in value:  # Check if the value contains coordinates\n                coordinates = value\n                left_click_coordinates_raw(coordinates)\n            else:  # Otherwise, treat it as an image name\n                image_name = value\n                left_click_image(image_name)\n        elif task.startswith(\"OOB_TextInput =\"):\n            text = task.split(\"=\")[1].strip()\n            text_input(text)\n        elif task.startswith(\"OOB_SpecialKey =\"):\n            key = task.split(\"=\")[1].strip()\n            special_key(key)\n        elif task.startswith(\"OOB_FunctionKey =\"):\n            key = task.split(\"=\")[1].strip()\n            function_key(key)\n        elif task.startswith(\"OOB_KeyCombo =\"):\n            combo = task.split(\"=\")[1].strip()\n            key_combo(combo)\n        elif task.startswith(\"OOB_Delay =\"):\n            delay = int(task.split(\"=\")[1].strip())\n            delay_task(delay)\n        elif task.startswith(\"OOB_MouseMove =\"):\n            coordinates = task.split(\"=\")[1].strip()\n            move_mouse_to_coordinates_raw(coordinates)\n        elif task == \"OOB_TakeScreenshot\":\n            take_screenshot_task()\n        elif task == \"OOB_PageUp\":\n            pyautogui.press(\"pageup\")\n        elif task == \"OOB_PageDown\":\n            pyautogui.press(\"pagedown\")\n        else:\n            print(f\"Unknown OOB task: {task}\")\n\n        time.sleep(0.2)\n\ndef execute_oob_tasks_with_delay():\n    \"\"\"\n    Executes the saved OOB tasks after a delay.\n    \"\"\"\n    time.sleep(0.1)  # Short delay to ensure the LLM's response has completed\n    with open(oob_tasks_file, 'r') as f:\n        oob_tasks = json.load(f)\n    execute_oob_tasks(oob_tasks)\n\ndef delay_task(delay):\n    \"\"\"\n    Adds a delay in milliseconds.\n    \"\"\"\n    time.sleep(delay / 1000.0)\n\ndef move_mouse_to_coordinates_raw(coordinates):\n    \"\"\"\n    Moves the mouse to the specified raw coordinates on the specified monitor.\n\n    Args:\n        coordinates (str): A string containing the monitor index and coordinates in the format \"monitor_index,x,y\".\n    \"\"\"\n    monitor_indexx, x, y = map(int, coordinates.split(\",\"))\n    monitors = screeninfo.get_monitors()\n\n    if monitor_indexx >= len(monitors):\n        raise ValueError(f\"Monitor index {monitor_indexx} is out of range. There are only {len(monitors)} monitors.\")\n\n    monitor = monitors[monitor_indexx]\n    monitor_x, monitor_y = monitor.x, monitor.y\n    absolute_x = monitor_x + x\n    absolute_y = monitor_y + y\n    pyautogui.moveTo(absolute_x, absolute_y)\n    print(f\"Mouse moved to coordinates: ({absolute_x}, {absolute_y}) on monitor {monitor_indexx}\")\n\ndef left_click_coordinates_raw(coordinates):\n    \"\"\"\n    Moves the mouse to the specified raw coordinates on the specified monitor and performs a left click.\n\n    Args:\n        coordinates (str): A string containing the monitor index and coordinates in the format \"monitor_index,x,y\".\n    \"\"\"\n    monitor_indexx, x, y = map(int, coordinates.split(\",\"))\n    monitors = screeninfo.get_monitors()\n\n    if monitor_indexx >= len(monitors):\n        raise ValueError(f\"Monitor index {monitor_indexx} is out of range. There are only {len(monitors)} monitors.\")\n\n    monitor = monitors[monitor_indexx]\n    monitor_x, monitor_y = monitor.x, monitor.y\n    absolute_x = monitor_x + x\n    absolute_y = monitor_y + y\n    pyautogui.moveTo(absolute_x, absolute_y)\n    pyautogui.click()\n    print(f\"Mouse clicked at coordinates: ({absolute_x}, {absolute_y}) on monitor {monitor_indexx}\")\n\ndef take_screenshot_task():\n    \"\"\"\n    Takes a screenshot using the current values from the Gradio interface.\n    \"\"\"\n    take_screenshot(global_vars[\"global_monitor_index\"], global_vars[\"global_text_queries\"], global_vars[\"global_score_threshold\"], global_vars[\"global_vision_model_question\"], global_vars[\"global_full_image_vision_model_question\"])\n\ndef move_mouse_to_image(image_name):\n    \"\"\"\n    Moves the mouse to the center of the box that defines the image.\n    \"\"\"\n    results_json_path = \"extensions/Lucid_Autonomy/ImageOutputTest/results.json\"\n    with open(results_json_path, 'r') as f:\n        results = json.load(f)\n\n    # Access the global monitor index from global_vars\n    monitor_index = global_vars.get(\"global_monitor_index\", MONITOR_INDEX)\n\n    for result in results:\n        if result[\"image_name\"] == image_name:\n            coordinates = result[\"coordinates\"]\n            monitor = get_monitor_info(monitor_index)\n            move_mouse_to_coordinates(monitor, coordinates)\n            break\n    else:\n        print(f\"Image name '{image_name}' not found in the results.\")\n\ndef left_click_image(image_name):\n    \"\"\"\n    Moves the mouse to the center of the box that defines the image and performs a left click.\n    \"\"\"\n    results_json_path = \"extensions/Lucid_Autonomy/ImageOutputTest/results.json\"\n    with open(results_json_path, 'r') as f:\n        results = json.load(f)\n\n    # Access the global monitor index from global_vars\n    monitor_index = global_vars.get(\"global_monitor_index\", MONITOR_INDEX)\n\n    for result in results:\n        if result[\"image_name\"] == image_name:\n            coordinates = result[\"coordinates\"]\n            monitor = get_monitor_info(monitor_index)  # Get the monitor information as a dictionary\n            move_mouse_to_coordinates(monitor, coordinates)\n            pyautogui.click()  # Perform a left click\n            break\n    else:\n        print(f\"Image name '{image_name}' not found in the results.\")\n\n\ndef move_mouse_to_coordinates(monitor, coordinates):\n    \"\"\"\n    Moves the mouse cursor to the specified coordinates on the monitor.\n\n    Args:\n        monitor (dict): A dictionary containing the monitor's information.\n        coordinates (list): A list containing the coordinates [x1, y1, x2, y2].\n    \"\"\"\n    x1, y1, x2, y2 = coordinates\n    monitor_x, monitor_y = monitor.x, monitor.y\n    center_x = monitor_x + (x1 + x2) // 2\n    center_y = monitor_y + (y1 + y2) // 2\n    pyautogui.moveTo(center_x, center_y)\n    print(f\"Mouse moved to coordinates: ({center_x}, {center_y})\")\n\ndef get_monitor_info(monitor_index):\n    \"\"\"\n    Gets information about the specified monitor.\n\n    Args:\n        monitor_index (int): The index of the monitor to get information about.\n\n    Returns:\n        dict: A dictionary containing the monitor's information.\n    \"\"\"\n    monitors = screeninfo.get_monitors()\n\n    if monitor_index >= len(monitors):\n        raise ValueError(f\"Monitor index {monitor_index} is out of range. There are only {len(monitors)} monitors.\")\n\n    return monitors[monitor_index]\n\n# Modify the history_modifier function\ndef history_modifier(history):\n    \"\"\"\n    Modifies the chat history before the text generation in chat mode begins.\n    \"\"\"\n    # Clean the internal history\n    history[\"internal\"] = clean_chat_history(history[\"internal\"])\n    # Clean the visible history\n    history[\"visible\"] = clean_chat_history(history[\"visible\"])\n\n    # Inject the latest results.json into the internal history if the checkbox is checked\n    if global_vars.get(\"use_results_json\", True):\n        results_json_path = \"extensions/Lucid_Autonomy/ImageOutputTest/results.json\"\n        with open(results_json_path, 'r') as f:\n            compressed_results = json.load(f)\n        latest_compressed_results = json.dumps(compressed_results, indent=4)\n        history[\"internal\"].append([\"\", f\"<START_COMPRESSED_RESULTS>\\n{latest_compressed_results}\\n<END_COMPRESSED_RESULTS>\"])\n\n    # Extract all entries from the \"internal\" history\n    internal_entries = history[\"internal\"]\n    # Iterate over the \"internal\" history entries\n    for internal_index, internal_entry in enumerate(internal_entries):\n        # Extract the text content of the internal entry\n        internal_text = internal_entry[1]\n        # Search for the \"Image_File_Location:\" trigger phrase in the internal text\n        file_location_matches = re.findall(r\"Image_File_Location: (.+)$\", internal_text, re.MULTILINE)\n        if file_location_matches:\n            # Iterate over each match found in the \"internal\" entry\n            for file_path in file_location_matches:\n                # Construct the full match string including the trigger phrase\n                full_match_string = f\"Image_File_Location: {file_path}\"\n                # Search for the exact same string in the \"visible\" history\n                for visible_entry in history[\"visible\"]:\n                    # Extract the text content of the visible entry\n                    visible_text = visible_entry[1]\n                    # If the \"visible\" entry contains the full match string\n                    if full_match_string in visible_text:\n                        # Split the \"visible\" text at the full match string\n                        _, after_match = visible_text.split(full_match_string, 1)\n                        # Find the position where the \".png\" part ends in the \"internal\" text\n                        png_end_pos = internal_text.find(file_path) + len(file_path)\n                        # If the \".png\" part is found and there is content after it\n                        if png_end_pos < len(internal_text) and internal_text[png_end_pos] == \"\\n\":\n                            # Extract the existing content after the \".png\" part in the \"internal\" text\n                            _ = internal_text[png_end_pos:]\n                            # Replace the existing content after the \".png\" part in the \"internal\" text\n                            # with the corresponding content from the \"visible\" text\n                            new_internal_text = internal_text[:png_end_pos] + after_match\n                            # Update the \"internal\" history entry with the new text\n                            history[\"internal\"][internal_index][1] = new_internal_text\n                        # If there is no content after the \".png\" part in the \"internal\" text,\n                        # append the content from the \"visible\" text directly\n                        else:\n                            # Append the content after the full match string from the \"visible\" text\n                            history[\"internal\"][internal_index][1] += after_match\n\n        # Search for the \"Data_File_Location:\" trigger phrase in the internal text\n        data_file_location_matches = re.findall(r\"Data_File_Location: (.+)$\", internal_text, re.MULTILINE)\n        if data_file_location_matches:\n            # Iterate over each match found in the \"internal\" entry\n            for file_path in data_file_location_matches:\n                # Construct the full match string including the trigger phrase\n                full_match_string = f\"Data_File_Location: {file_path}\"\n                # Search for the exact same string in the \"visible\" history\n                for visible_entry in history[\"visible\"]:\n                    # Extract the text content of the visible entry\n                    visible_text = visible_entry[1]\n                    # If the \"visible\" entry contains the full match string\n                    if full_match_string in visible_text:\n                        # Split the \"visible\" text at the full match string\n                        _, after_match = visible_text.split(full_match_string, 1)\n                        # Find the position where the \".png\" part ends in the \"internal\" text\n                        png_end_pos = internal_text.find(file_path) + len(file_path)\n                        # If the \".png\" part is found and there is content after it\n                        if png_end_pos < len(internal_text) and internal_text[png_end_pos] == \"\\n\":\n                            # Extract the existing content after the \".png\" part in the \"internal\" text\n                            _ = internal_text[png_end_pos:]\n                            # Replace the existing content after the \".png\" part in the \"internal\" text\n                            # with the corresponding content from the \"visible\" text\n                            new_internal_text = internal_text[:png_end_pos] + after_match\n                            # Update the \"internal\" history entry with the new text\n                            history[\"internal\"][internal_index][1] = new_internal_text\n                        # If there is no content after the \".png\" part in the \"internal\" text,\n                        # append the content from the \"visible\" text directly\n                        else:\n                            # Append the content after the full match string from the \"visible\" text\n                            history[\"internal\"][internal_index][1] += after_match\n        # Search for the \"ARIA_File_Location:\" trigger phrase in the internal text\n        data_file_location_matches = re.findall(r\"ARIA_File_Location: (.+)$\", internal_text, re.MULTILINE)\n        if data_file_location_matches:\n            # Iterate over each match found in the \"internal\" entry\n            for file_path in data_file_location_matches:\n                # Construct the full match string including the trigger phrase\n                full_match_string = f\"ARIA_File_Location: {file_path}\"\n                # Search for the exact same string in the \"visible\" history\n                for visible_entry in history[\"visible\"]:\n                    # Extract the text content of the visible entry\n                    visible_text = visible_entry[1]\n                    # If the \"visible\" entry contains the full match string\n                    if full_match_string in visible_text:\n                        # Split the \"visible\" text at the full match string\n                        _, after_match = visible_text.split(full_match_string, 1)\n                        # Find the position where the \".png\" part ends in the \"internal\" text\n                        png_end_pos = internal_text.find(file_path) + len(file_path)\n                        # If the \".png\" part is found and there is content after it\n                        if png_end_pos < len(internal_text) and internal_text[png_end_pos] == \"\\n\":\n                            # Extract the existing content after the \".png\" part in the \"internal\" text\n                            _ = internal_text[png_end_pos:]\n                            # Replace the existing content after the \".png\" part in the \"internal\" text\n                            # with the corresponding content from the \"visible\" text\n                            new_internal_text = internal_text[:png_end_pos] + after_match\n                            # Update the \"internal\" history entry with the new text\n                            history[\"internal\"][internal_index][1] = new_internal_text\n                        # If there is no content after the \".png\" part in the \"internal\" text,\n                        # append the content from the \"visible\" text directly\n                        else:\n                            # Append the content after the full match string from the \"visible\" text\n                            history[\"internal\"][internal_index][1] += after_match\n\n    return history\n\ndef clean_chat_history(history):\n    \"\"\"\n    Cleans the chat history by removing all but the latest instance of the contents between the bookends.\n    \"\"\"\n    START_BOOKEND = \"<START_COMPRESSED_RESULTS>\"\n    END_BOOKEND = \"<END_COMPRESSED_RESULTS>\"\n\n    # Find all instances of the bookends\n    bookend_indices = []\n    for i, entry in enumerate(history):\n        if isinstance(entry, list) and len(entry) == 2:\n            if START_BOOKEND in entry[1] and END_BOOKEND in entry[1]:\n                bookend_indices.append(i)\n\n    # If there are multiple instances, remove all but the last one\n    if len(bookend_indices) > 1:\n        for i in bookend_indices[:-1]:\n            history[i][1] = re.sub(f\"{START_BOOKEND}.*?{END_BOOKEND}\", \"\", history[i][1], flags=re.DOTALL)\n\n    return history\n\ndef append_compressed_results(output, compressed_results):\n    \"\"\"\n    Appends the compressed results to the output.\n    \"\"\"\n    START_BOOKEND = \"<START_COMPRESSED_RESULTS>\"\n    END_BOOKEND = \"<END_COMPRESSED_RESULTS>\"\n    output += f\"\\n{START_BOOKEND}\\n{json.dumps(compressed_results, indent=4)}\\n{END_BOOKEND}\"\n    return output\n\ndef text_input(text):\n    \"\"\"\n    Types the given text, replacing '/n' with newline characters.\n    \"\"\"\n    text = text.replace(\"/n\", \"\\n\")\n    pyautogui.typewrite(text)\n\ndef special_key(key):\n    \"\"\"\n    Presses the specified special key.\n    \"\"\"\n    if key == \"enter\":\n        pyautogui.press(\"enter\")\n    elif key == \"space\":\n        pyautogui.press(\"space\")\n    elif key == \"backspace\":\n        pyautogui.press(\"backspace\")\n    elif key == \"tab\":\n        pyautogui.press(\"tab\")\n    elif key == \"escape\":\n        pyautogui.press(\"esc\")\n    elif key == \"shift\":\n        pyautogui.press(\"shift\")\n    elif key == \"ctrl\":\n        pyautogui.press(\"ctrl\")\n    elif key == \"alt\":\n        pyautogui.press(\"alt\")\n    else:\n        print(f\"Unsupported special key: {key}\")\n\ndef function_key(key):\n    \"\"\"\n    Presses the specified function key.\n    \"\"\"\n    if key.startswith(\"f\") and key[1:].isdigit():\n        pyautogui.press(key)\n    else:\n        print(f\"Unsupported function key: {key}\")\n\ndef key_combo(combo):\n    \"\"\"\n    Presses the specified key combination.\n    \"\"\"\n    keys = combo.split(\"+\")\n    for key in keys:\n        if key in [\"ctrl\", \"alt\", \"shift\"]:\n            pyautogui.keyDown(key)\n        else:\n            pyautogui.press(key)\n    for key in keys:\n        if key in [\"ctrl\", \"alt\", \"shift\"]:\n            pyautogui.keyUp(key)\n\n# Main execution\nif __name__ == \"__main__\":\n    # Launch the Gradio interface with the specified UI components\n    gr.Interface(\n        fn=ui,\n        inputs=None,\n        outputs=\"ui\"\n    ).launch()\n```",
            "To integrate the GOT-OCR and Aria models into `LucidVision.py`, you need to add the necessary functions and update the existing ones to handle these models. Below are the updated or new functions for `LucidVision.py`:\n\n### New Functions\n\n#### Load and Unload GOT-OCR Model\n```python\ndef load_got_ocr_model():\n    global got_ocr_model, got_ocr_tokenizer\n    os.environ[\"CUDA_VISIBLE_DEVICES\"] = \"0\"\n    torch.cuda.set_device(0)  # Explicitly set CUDA device\n\n    got_ocr_model = AutoModel.from_pretrained(config[\"got_ocr_model_id\"], trust_remote_code=True, low_cpu_mem_usage=True, device_map='cuda:0', use_safetensors=True).eval().cuda()\n    got_ocr_tokenizer = AutoTokenizer.from_pretrained(config[\"got_ocr_model_id\"], trust_remote_code=True)\n    print(\"GOT-OCR model loaded.\")\n\ndef unload_got_ocr_model():\n    global got_ocr_model, got_ocr_tokenizer\n    if got_ocr_model is not None:\n        del got_ocr_model\n        del got_ocr_tokenizer\n        torch.cuda.empty_cache()\n        print(\"GOT-OCR model unloaded.\")\n```\n\n#### Process with GOT-OCR Model\n```python\ndef process_with_got_ocr_model(image_path, got_mode, fine_grained_mode=\"\", ocr_color=\"\", ocr_box=\"\"):\n    load_got_ocr_model()\n    try:\n        if got_mode == \"plain texts OCR\":\n            res = got_ocr_model.chat(got_ocr_tokenizer, image_path, ocr_type='ocr')\n            return res, None\n        elif got_mode == \"format texts OCR\":\n            res = got_ocr_model.chat(got_ocr_tokenizer, image_path, ocr_type='format', render=True, save_render_file=result_path)\n        elif got_mode == \"plain multi-crop OCR\":\n            res = got_ocr_model.chat_crop(got_ocr_tokenizer, image_path, ocr_type='ocr')\n            return res, None\n        elif got_mode == \"format multi-crop OCR\":\n            res = got_ocr_model.chat_crop(got_ocr_tokenizer, image_path, ocr_type='format', render=True, save_render_file=result_path)\n        elif got_mode == \"plain fine-grained OCR\":\n            res = got_ocr_model.chat(got_ocr_tokenizer, image_path, ocr_type='ocr', ocr_box=ocr_box, ocr_color=ocr_color)\n            return res, None\n        elif got_mode == \"format fine-grained OCR\":\n            res = got_ocr_model.chat(got_ocr_tokenizer, image_path, ocr_type='format', ocr_box=ocr_box, ocr_color=ocr_color, render=True, save_render_file=result_path)\n\n        res_markdown = res\n\n        if \"format\" in got_mode and os.path.exists(result_path):\n            with open(result_path, 'r') as f:\n                html_content = f.read()\n            encoded_html = base64.b64encode(html_content.encode('utf-8')).decode('utf-8')\n            iframe_src = f\"data:text/html;base64,{encoded_html}\"\n            iframe = f'<iframe src=\"{iframe_src}\" width=\"100%\" height=\"600px\"></iframe>'\n            download_link = f'<a href=\"data:text/html;base64,{encoded_html}\" download=\"result_{unique_id}.html\">Download Full Result</a>'\n            return res_markdown, f\"{download_link}<br>{iframe}\"\n        else:\n            return res_markdown, None\n    except Exception as e:\n        return f\"Error: {str(e)}\", None\n    finally:\n        unload_got_ocr_model()\n```\n\n#### Load and Unload Aria Model\n```python\ndef load_aria_model():\n    global aria_model, aria_processor\n    if aria_model is None:\n        print(\"Loading ARIA model...\")\n        aria_model = AutoModelForCausalLM.from_pretrained(\n            config[\"aria_model_id\"],\n            device_map=\"auto\",\n            torch_dtype=torch.bfloat16,\n            trust_remote_code=True\n        )\n        aria_processor = AutoProcessor.from_pretrained(\n            config[\"aria_model_id\"],\n            trust_remote_code=True\n        )\n        print(\"ARIA model loaded successfully.\")\n    else:\n        print(\"ARIA model already loaded.\")\n\ndef unload_aria_model():\n    global aria_model, aria_processor\n    if aria_model is not None:\n        print(\"Unloading ARIA model...\")\n        # Move model to CPU before deletion\n        aria_model.cpu()\n        # Delete the model and processor\n        del aria_model\n        del aria_processor\n        # Set to None to indicate they're unloaded\n        aria_model = None\n        aria_processor = None\n        # Clear CUDA cache\n        if torch.cuda.is_available():\n            torch.cuda.empty_cache()\n        # Run garbage collection\n        gc.collect()\n        print(\"ARIA model unloaded successfully.\")\n    else:\n        print(\"ARIA model not loaded, nothing to unload.\")\n\n    # Print current GPU memory usage\n    if torch.cuda.is_available():\n        print(f\"Current GPU memory allocated: {torch.cuda.memory_allocated() / 1e9:.2f} GB\")\n        print(f\"Current GPU memory reserved: {torch.cuda.memory_reserved() / 1e9:.2f} GB\")\n```\n\n#### Process with Aria Model\n```python\ndef process_with_aria_model(image_path, question):\n    global aria_model, aria_processor\n\n    if aria_model is None:\n        load_aria_model()\n\n    print(\"Processing image with ARIA model...\")\n    image = Image.open(image_path).convert(\"RGB\")\n    messages = [\n        {\"role\": \"user\", \"content\": [\n            {\"text\": None, \"type\": \"image\"},\n            {\"text\": question, \"type\": \"text\"},\n        ]}\n    ]\n\n    text = aria_processor.apply_chat_template(messages, add_generation_prompt=True)\n    inputs = aria_processor(text=text, images=image, return_tensors=\"pt\")\n    inputs[\"pixel_values\"] = inputs[\"pixel_values\"].to(aria_model.dtype)\n    inputs = {k: v.to(aria_model.device) for k, v in inputs.items()}\n\n    with torch.inference_mode(), torch.cuda.amp.autocast(dtype=torch.bfloat16):\n        output = aria_model.generate(\n            **inputs,\n            max_new_tokens=1024,\n            stop_strings=[\"<|im_end|>\"],\n            tokenizer=aria_processor.tokenizer,\n            do_sample=True,\n            temperature=0.9,\n        )\n        output_ids = output[0][inputs[\"input_ids\"].shape[1]:]\n        result = aria_processor.decode(output_ids, skip_special_tokens=True)\n\n    print(\"Image processing complete.\")\n    return result\n```\n\n### Updated Functions\n\n#### Update `process_with_vision_model`\n```python\ndef process_with_vision_model(user_input, image, selected_model):\n    global cuda_device\n    # Save the uploaded image to the specified directory with a timestamp\n    file_name = get_timestamped_filename()\n    file_path = image_history_dir / file_name\n    image.save(file_path, format='PNG')\n    print(f\"Image processed: {file_path}\")\n\n    # Initialize an empty response string\n    vision_model_response = \"\"\n\n    # Check which vision model is currently selected\n    if selected_model == \"phiVision\":\n        vision_model_response = generate_phi_vision(file_path, user_input)\n\n    elif selected_model == \"DeepSeek\":\n        vision_model_response = generate_deepseek(file_path, user_input)\n\n    elif selected_model == \"paligemma\":\n        vision_model_response = generate_paligemma(file_path, user_input)\n\n    elif selected_model == \"paligemma_cpu\":\n        vision_model_response = generate_paligemma_cpu(file_path, user_input)\n\n    elif selected_model == \"minicpm_llama3\":\n        vision_model_response = generate_minicpm_llama3(file_path, user_input)\n\n    elif selected_model == \"bunny\":\n        vision_model_response = generate_bunny(file_path, user_input)\n\n    elif selected_model == \"got_ocr\":\n        vision_model_response, _ = process_with_got_ocr_model(file_path, got_mode=\"plain texts OCR\")\n\n    elif selected_model == \"aria\":\n        vision_model_response = process_with_aria_model(file_path, user_input)\n\n    # Return the cleaned-up response from the vision model\n    return vision_model_response\n```\n\n#### Update `update_vision_model`\n```python\ndef update_vision_model(model_name):\n    global selected_vision_model\n    selected_vision_model = model_name\n    return model_name\n```\n\n#### Update `ui`\n```python\ndef ui():\n    # Create an image input component for the Gradio UI\n    image_input = gr.Image(label=\"Select an Image\", type=\"pil\", source=\"upload\")\n    # Set up the event that occurs when an image is uploaded\n    image_input.change(\n        fn=save_and_print_image_path,\n        inputs=image_input,\n        outputs=None\n    )\n\n    # Create a text field for user input to the vision model\n    user_input_to_vision_model = gr.Textbox(label=\"Type your question or prompt for the vision model\", lines=2,\n                                            placeholder=\"Enter your text here...\")\n\n    # Create a button to trigger the vision model processing\n    vision_model_button = gr.Button(value=\"Ask Vision Model\")\n\n    # Create a text field to display the vision model's response\n    vision_model_response_output = gr.Textbox(\n        label=\"Vision Model Response\",\n        lines=5,\n        placeholder=\"Response will appear here...\"\n    )\n\n    # Add radio buttons for vision model selection\n    vision_model_selection = gr.Radio(\n        choices=model_names + [\"got_ocr\", \"aria\"],\n        value=config[\"default_vision_model\"],\n        label=\"Select Vision Model\"\n    )\n\n    # Add an event handler for the radio button selection\n    vision_model_selection.change(\n        fn=update_vision_model,\n        inputs=vision_model_selection,\n        outputs=None\n    )\n\n    cuda_devices_input = gr.Textbox(\n        value=cuda_device,\n        label=\"CUDA Device ID\",\n        max_lines=1\n    )\n\n    cuda_devices_input.change(\n        fn=update_cuda_device,\n        inputs=cuda_devices_input,\n        outputs=None\n    )\n\n    # Set up the event that occurs when the vision model button is clicked\n    vision_model_button.click(\n        fn=process_with_vision_model,\n        inputs=[user_input_to_vision_model, image_input, vision_model_selection],\n        outputs=vision_model_response_output\n    )\n\n    # Return a column containing the UI components\n    return gr.Column(\n        [\n            image_input,\n            user_input_to_vision_model,\n            vision_model_button,\n            vision_model_response_output,\n            vision_model_selection\n        ]\n    )\n```\n\n### Update Config File\nAdd the following lines to the config file:\n```json\n{\n    \"got_ocr_model_id\": \"/home/myself/Desktop/GOT_OCR/ModelGOT-OCR2_0/\",\n    \"aria_model_id\": \"/home/myself/Desktop/Aria/\"\n}\n```\n\nThese updates should integrate the GOT-OCR and Aria models into `LucidVision.py` while maintaining the existing functionality."
        ],
        [
            "What about the def output_modifier in the LucidVision.py code?\n\n```\n# Function to modify the output from the LLM before it is displayed to the user\ndef output_modifier(output, state, is_chat=False):\n    global cuda_device\n    # Search for the \"File location\" trigger phrase in the LLM's output\n    file_location_matches = file_location_pattern.findall(output)\n    if file_location_matches:\n        # Extract the first match (assuming only one file location per output)\n        file_path = file_location_matches[0]\n        # Extract the questions for the vision model\n        questions_section, _ = output.split(f\"File location: {file_path}\", 1)\n        # Remove all newlines from the questions section and replace them with spaces\n        questions = \" \".join(questions_section.strip().splitlines())\n\n        # Initialize an empty response string\n        vision_model_response = \"\"\n\n        # Check which vision model is currently selected\n        if selected_vision_model == \"phiVision\":\n            vision_model_response = generate_phi_vision(file_path, questions)\n\n        elif selected_vision_model == \"DeepSeek\":\n            vision_model_response = generate_deepseek(file_path, questions)\n\n        elif selected_vision_model == \"paligemma\":\n            vision_model_response = generate_paligemma(file_path, questions)\n\n        elif selected_vision_model == \"paligemma_cpu\":\n            vision_model_response = generate_paligemma_cpu(file_path, questions)\n\n        elif selected_vision_model == \"minicpm_llama3\":\n            vision_model_response = generate_minicpm_llama3(file_path, questions)\n\n        elif selected_vision_model == \"bunny\":\n            vision_model_response = generate_bunny(file_path, questions)\n\n        # Append the vision model's responses to the output\n        output_with_responses = f\"{output}\\n\\nVision Model Responses:\\n{vision_model_response}\"\n        return output_with_responses\n    # If no file location is found, return the output as is\n    return output\n```",
            "To update the `output_modifier` function to handle the new GOT-OCR and Aria models, you need to add conditions for these models in the function. Here is the updated `output_modifier` function:\n\n### Updated `output_modifier` Function\n```python\n# Function to modify the output from the LLM before it is displayed to the user\ndef output_modifier(output, state, is_chat=False):\n    global cuda_device\n    # Search for the \"File location\" trigger phrase in the LLM's output\n    file_location_matches = file_location_pattern.findall(output)\n    if file_location_matches:\n        # Extract the first match (assuming only one file location per output)\n        file_path = file_location_matches[0]\n        # Extract the questions for the vision model\n        questions_section, _ = output.split(f\"File location: {file_path}\", 1)\n        # Remove all newlines from the questions section and replace them with spaces\n        questions = \" \".join(questions_section.strip().splitlines())\n\n        # Initialize an empty response string\n        vision_model_response = \"\"\n\n        # Check which vision model is currently selected\n        if selected_vision_model == \"phiVision\":\n            vision_model_response = generate_phi_vision(file_path, questions)\n\n        elif selected_vision_model == \"DeepSeek\":\n            vision_model_response = generate_deepseek(file_path, questions)\n\n        elif selected_vision_model == \"paligemma\":\n            vision_model_response = generate_paligemma(file_path, questions)\n\n        elif selected_vision_model == \"paligemma_cpu\":\n            vision_model_response = generate_paligemma_cpu(file_path, questions)\n\n        elif selected_vision_model == \"minicpm_llama3\":\n            vision_model_response = generate_minicpm_llama3(file_path, questions)\n\n        elif selected_vision_model == \"bunny\":\n            vision_model_response = generate_bunny(file_path, questions)\n\n        elif selected_vision_model == \"got_ocr\":\n            vision_model_response, _ = process_with_got_ocr_model(file_path, got_mode=\"plain texts OCR\")\n\n        elif selected_vision_model == \"aria\":\n            vision_model_response = process_with_aria_model(file_path, questions)\n\n        # Append the vision model's responses to the output\n        output_with_responses = f\"{output}\\n\\nVision Model Responses:\\n{vision_model_response}\"\n        return output_with_responses\n    # If no file location is found, return the output as is\n    return output\n```\n\n### Summary of Changes\n1. **Added Conditions for GOT-OCR and Aria Models**: The `output_modifier` function now includes conditions to handle the GOT-OCR and Aria models.\n2. **Process with GOT-OCR Model**: The `process_with_got_ocr_model` function is called when the selected model is `got_ocr`.\n3. **Process with Aria Model**: The `process_with_aria_model` function is called when the selected model is `aria`.\n\nThese updates ensure that the `output_modifier` function can handle the new models and integrate their responses into the output."
        ],
        [
            "In this function:\n\n```\ndef process_with_got_ocr_model(image_path, got_mode, fine_grained_mode=\"\", ocr_color=\"\", ocr_box=\"\"):\n    load_got_ocr_model()\n    try:\n        if got_mode == \"plain texts OCR\":\n            res = got_ocr_model.chat(got_ocr_tokenizer, image_path, ocr_type='ocr')\n            return res, None\n        elif got_mode == \"format texts OCR\":\n            res = got_ocr_model.chat(got_ocr_tokenizer, image_path, ocr_type='format', render=True, save_render_file=result_path)\n        elif got_mode == \"plain multi-crop OCR\":\n            res = got_ocr_model.chat_crop(got_ocr_tokenizer, image_path, ocr_type='ocr')\n            return res, None\n        elif got_mode == \"format multi-crop OCR\":\n            res = got_ocr_model.chat_crop(got_ocr_tokenizer, image_path, ocr_type='format', render=True, save_render_file=result_path)\n        elif got_mode == \"plain fine-grained OCR\":\n            res = got_ocr_model.chat(got_ocr_tokenizer, image_path, ocr_type='ocr', ocr_box=ocr_box, ocr_color=ocr_color)\n            return res, None\n        elif got_mode == \"format fine-grained OCR\":\n            res = got_ocr_model.chat(got_ocr_tokenizer, image_path, ocr_type='format', ocr_box=ocr_box, ocr_color=ocr_color, render=True, save_render_file=result_path)\n\n        res_markdown = res\n\n        if \"format\" in got_mode and os.path.exists(result_path):\n            with open(result_path, 'r') as f:\n                html_content = f.read()\n            encoded_html = base64.b64encode(html_content.encode('utf-8')).decode('utf-8')\n            iframe_src = f\"data:text/html;base64,{encoded_html}\"\n            iframe = f'<iframe src=\"{iframe_src}\" width=\"100%\" height=\"600px\"></iframe>'\n            download_link = f'<a href=\"data:text/html;base64,{encoded_html}\" download=\"result_{unique_id}.html\">Download Full Result</a>'\n            return res_markdown, f\"{download_link}<br>{iframe}\"\n        else:\n            return res_markdown, None\n    except Exception as e:\n        return f\"Error: {str(e)}\", None\n    finally:\n        unload_got_ocr_model()\n```\nI'm seeing this error: undefined name result_path",
            "The error you're encountering is due to the `result_path` variable not being defined in the `process_with_got_ocr_model` function. To fix this, you need to define `result_path` and `unique_id` within the function. Here is the corrected version of the function:\n\n### Updated `process_with_got_ocr_model` Function\n```python\nimport uuid\nimport base64\n\ndef process_with_got_ocr_model(image_path, got_mode, fine_grained_mode=\"\", ocr_color=\"\", ocr_box=\"\"):\n    load_got_ocr_model()\n    try:\n        unique_id = str(uuid.uuid4())\n        result_path = f\"extensions/Lucid_Autonomy/ImageOutputTest/result_{unique_id}.html\"\n\n        if got_mode == \"plain texts OCR\":\n            res = got_ocr_model.chat(got_ocr_tokenizer, image_path, ocr_type='ocr')\n            return res, None\n        elif got_mode == \"format texts OCR\":\n            res = got_ocr_model.chat(got_ocr_tokenizer, image_path, ocr_type='format', render=True, save_render_file=result_path)\n        elif got_mode == \"plain multi-crop OCR\":\n            res = got_ocr_model.chat_crop(got_ocr_tokenizer, image_path, ocr_type='ocr')\n            return res, None\n        elif got_mode == \"format multi-crop OCR\":\n            res = got_ocr_model.chat_crop(got_ocr_tokenizer, image_path, ocr_type='format', render=True, save_render_file=result_path)\n        elif got_mode == \"plain fine-grained OCR\":\n            res = got_ocr_model.chat(got_ocr_tokenizer, image_path, ocr_type='ocr', ocr_box=ocr_box, ocr_color=ocr_color)\n            return res, None\n        elif got_mode == \"format fine-grained OCR\":\n            res = got_ocr_model.chat(got_ocr_tokenizer, image_path, ocr_type='format', ocr_box=ocr_box, ocr_color=ocr_color, render=True, save_render_file=result_path)\n\n        res_markdown = res\n\n        if \"format\" in got_mode and os.path.exists(result_path):\n            with open(result_path, 'r') as f:\n                html_content = f.read()\n            encoded_html = base64.b64encode(html_content.encode('utf-8')).decode('utf-8')\n            iframe_src = f\"data:text/html;base64,{encoded_html}\"\n            iframe = f'<iframe src=\"{iframe_src}\" width=\"100%\" height=\"600px\"></iframe>'\n            download_link = f'<a href=\"data:text/html;base64,{encoded_html}\" download=\"result_{unique_id}.html\">Download Full Result</a>'\n            return res_markdown, f\"{download_link}<br>{iframe}\"\n        else:\n            return res_markdown, None\n    except Exception as e:\n        return f\"Error: {str(e)}\", None\n    finally:\n        unload_got_ocr_model()\n```\n\n### Summary of Changes\n1. **Defined `result_path` and `unique_id`**: These variables are now defined within the function to ensure they are available when needed.\n2. **Imported Required Modules**: Added `import uuid` and `import base64` to handle the generation of unique IDs and encoding of HTML content.\n\nThese changes should resolve the `undefined name result_path` error and ensure that the function works correctly."
        ],
        [
            "Okay, I get this error in the \"Vision Model Response\" UI window when I try to use the got-ocr model:\n```\nError: 'PosixPath' object has no attribute 'startswith'\n```\n\nThis is what I see in the terminal:\n\n```\n14:47:14-266842 INFO     Starting Text generation web UI                        \n14:47:14-268710 INFO     Loading settings from \"settings.yaml\"                  \n14:47:14-270854 INFO     Loading the extension                                  \n                         \"text-generation-webui-model_ducking\"                  \n14:47:14-329797 INFO     Loading the extension \"Lucid_Vision\"                   \n14:47:14-938519 INFO     Loading the extension \"Lucid_Autonomy\"                 \n\nRunning on local URL:  http://127.0.0.1:7861\n\nImage selected: /home/myself/Desktop/OobV115/text-generation-webui/extensions/Lucid_Vision/Image_History/image_20241020_144815.png\nImage processed: /home/myself/Desktop/OobV115/text-generation-webui/extensions/Lucid_Vision/Image_History/image_20241020_144818.png\nGOT-OCR model loaded.\nGOT-OCR model unloaded.\n```",
            "The error `'PosixPath' object has no attribute 'startswith'` suggests that there is an issue with how the file path is being handled. The `PosixPath` object from the `pathlib` module does not have a `startswith` method. Instead, you should use the `str` method to convert the `PosixPath` object to a string before using `startswith`.\n\nLet's update the `process_with_got_ocr_model` function to handle this correctly. Additionally, we'll ensure that the `result_path` is correctly defined and used.\n\n### Updated `process_with_got_ocr_model` Function\n```python\nimport uuid\nimport base64\n\ndef process_with_got_ocr_model(image_path, got_mode, fine_grained_mode=\"\", ocr_color=\"\", ocr_box=\"\"):\n    load_got_ocr_model()\n    try:\n        unique_id = str(uuid.uuid4())\n        result_path = f\"extensions/Lucid_Autonomy/ImageOutputTest/result_{unique_id}.html\"\n\n        if got_mode == \"plain texts OCR\":\n            res = got_ocr_model.chat(got_ocr_tokenizer, str(image_path), ocr_type='ocr')\n            return res, None\n        elif got_mode == \"format texts OCR\":\n            res = got_ocr_model.chat(got_ocr_tokenizer, str(image_path), ocr_type='format', render=True, save_render_file=result_path)\n        elif got_mode == \"plain multi-crop OCR\":\n            res = got_ocr_model.chat_crop(got_ocr_tokenizer, str(image_path), ocr_type='ocr')\n            return res, None\n        elif got_mode == \"format multi-crop OCR\":\n            res = got_ocr_model.chat_crop(got_ocr_tokenizer, str(image_path), ocr_type='format', render=True, save_render_file=result_path)\n        elif got_mode == \"plain fine-grained OCR\":\n            res = got_ocr_model.chat(got_ocr_tokenizer, str(image_path), ocr_type='ocr', ocr_box=ocr_box, ocr_color=ocr_color)\n            return res, None\n        elif got_mode == \"format fine-grained OCR\":\n            res = got_ocr_model.chat(got_ocr_tokenizer, str(image_path), ocr_type='format', ocr_box=ocr_box, ocr_color=ocr_color, render=True, save_render_file=result_path)\n\n        res_markdown = res\n\n        if \"format\" in got_mode and os.path.exists(result_path):\n            with open(result_path, 'r') as f:\n                html_content = f.read()\n            encoded_html = base64.b64encode(html_content.encode('utf-8')).decode('utf-8')\n            iframe_src = f\"data:text/html;base64,{encoded_html}\"\n            iframe = f'<iframe src=\"{iframe_src}\" width=\"100%\" height=\"600px\"></iframe>'\n            download_link = f'<a href=\"data:text/html;base64,{encoded_html}\" download=\"result_{unique_id}.html\">Download Full Result</a>'\n            return res_markdown, f\"{download_link}<br>{iframe}\"\n        else:\n            return res_markdown, None\n    except Exception as e:\n        return f\"Error: {str(e)}\", None\n    finally:\n        unload_got_ocr_model()\n```\n\n### Summary of Changes\n1. **Convert `image_path` to String**: The `image_path` is converted to a string using `str(image_path)` before passing it to the `got_ocr_model.chat` method.\n2. **Defined `result_path` and `unique_id`**: These variables are now defined within the function to ensure they are available when needed.\n3. **Imported Required Modules**: Added `import uuid` and `import base64` to handle the generation of unique IDs and encoding of HTML content.\n\nThese changes should resolve the `'PosixPath' object has no attribute 'startswith'` error and ensure that the function works correctly."
        ],
        [
            "Yippy!!! The GOT-OCR model works :3 Good LLM *head pats*\n\nOkay, now I'm trying the aria model and am getting this error:\n\n```\n                         \"text-generation-webui-model_ducking\"                  \n14:51:36-018775 INFO     Loading the extension \"Lucid_Vision\"                   \n14:51:36-627019 INFO     Loading the extension \"Lucid_Autonomy\"                 \n\nRunning on local URL:  http://127.0.0.1:7861\n\nImage selected: /home/myself/Desktop/OobV115/text-generation-webui/extensions/Lucid_Vision/Image_History/image_20241020_145144.png\nImage processed: /home/myself/Desktop/OobV115/text-generation-webui/extensions/Lucid_Vision/Image_History/image_20241020_145147.png\nGOT-OCR model loaded.\nGOT-OCR model unloaded.\nNo image selected yet.\nImage selected: /home/myself/Desktop/OobV115/text-generation-webui/extensions/Lucid_Vision/Image_History/image_20241020_145236.png\nImage processed: /home/myself/Desktop/OobV115/text-generation-webui/extensions/Lucid_Vision/Image_History/image_20241020_145238.png\nTraceback (most recent call last):\n  File \"/home/myself/Desktop/OobV115/text-generation-webui/installer_files/env/lib/python3.11/site-packages/gradio/queueing.py\", line 527, in process_events\n    response = await route_utils.call_process_api(\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/myself/Desktop/OobV115/text-generation-webui/installer_files/env/lib/python3.11/site-packages/gradio/route_utils.py\", line 261, in call_process_api\n    output = await app.get_blocks().process_api(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/myself/Desktop/OobV115/text-generation-webui/installer_files/env/lib/python3.11/site-packages/gradio/blocks.py\", line 1786, in process_api\n    result = await self.call_function(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/myself/Desktop/OobV115/text-generation-webui/installer_files/env/lib/python3.11/site-packages/gradio/blocks.py\", line 1338, in call_function\n    prediction = await anyio.to_thread.run_sync(\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/myself/Desktop/OobV115/text-generation-webui/installer_files/env/lib/python3.11/site-packages/anyio/to_thread.py\", line 56, in run_sync\n    return await get_async_backend().run_sync_in_worker_thread(\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/myself/Desktop/OobV115/text-generation-webui/installer_files/env/lib/python3.11/site-packages/anyio/_backends/_asyncio.py\", line 2441, in run_sync_in_worker_thread\n    return await future\n           ^^^^^^^^^^^^\n  File \"/home/myself/Desktop/OobV115/text-generation-webui/installer_files/env/lib/python3.11/site-packages/anyio/_backends/_asyncio.py\", line 943, in run\n    result = context.run(func, *args)\n             ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/myself/Desktop/OobV115/text-generation-webui/installer_files/env/lib/python3.11/site-packages/gradio/utils.py\", line 759, in wrapper\n    response = f(*args, **kwargs)\n               ^^^^^^^^^^^^^^^^^^\n  File \"/home/myself/Desktop/OobV115/text-generation-webui/extensions/Lucid_Vision/script.py\", line 640, in process_with_vision_model\n    vision_model_response = process_with_aria_model(file_path, user_input)\n                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/myself/Desktop/OobV115/text-generation-webui/extensions/Lucid_Vision/script.py\", line 484, in process_with_aria_model\n    if aria_model is None:\n       ^^^^^^^^^^\nNameError: name 'aria_model' is not defined\n\n```",
            "The error `NameError: name 'aria_model' is not defined` indicates that the `aria_model` variable is not defined in the scope where it is being used. This typically happens if the variable is not declared as a global variable or if it is not properly initialized.\n\nTo fix this, ensure that `aria_model` and `aria_processor` are declared as global variables and properly initialized in the `load_aria_model` function. Additionally, make sure that the `process_with_aria_model` function is correctly referencing these global variables.\n\nHere is the updated code to address these issues:\n\n### Updated `load_aria_model` Function\n```python\naria_model = None\naria_processor = None\n\ndef load_aria_model():\n    global aria_model, aria_processor\n    if aria_model is None:\n        print(\"Loading ARIA model...\")\n        aria_model = AutoModelForCausalLM.from_pretrained(\n            config[\"aria_model_id\"],\n            device_map=\"auto\",\n            torch_dtype=torch.bfloat16,\n            trust_remote_code=True\n        )\n        aria_processor = AutoProcessor.from_pretrained(\n            config[\"aria_model_id\"],\n            trust_remote_code=True\n        )\n        print(\"ARIA model loaded successfully.\")\n    else:\n        print(\"ARIA model already loaded.\")\n```\n\n### Updated `unload_aria_model` Function\n```python\ndef unload_aria_model():\n    global aria_model, aria_processor\n    if aria_model is not None:\n        print(\"Unloading ARIA model...\")\n        # Move model to CPU before deletion\n        aria_model.cpu()\n        # Delete the model and processor\n        del aria_model\n        del aria_processor\n        # Set to None to indicate they're unloaded\n        aria_model = None\n        aria_processor = None\n        # Clear CUDA cache\n        if torch.cuda.is_available():\n            torch.cuda.empty_cache()\n        # Run garbage collection\n        gc.collect()\n        print(\"ARIA model unloaded successfully.\")\n    else:\n        print(\"ARIA model not loaded, nothing to unload.\")\n\n    # Print current GPU memory usage\n    if torch.cuda.is_available():\n        print(f\"Current GPU memory allocated: {torch.cuda.memory_allocated() / 1e9:.2f} GB\")\n        print(f\"Current GPU memory reserved: {torch.cuda.memory_reserved() / 1e9:.2f} GB\")\n```\n\n### Updated `process_with_aria_model` Function\n```python\ndef process_with_aria_model(image_path, question):\n    global aria_model, aria_processor\n\n    if aria_model is None:\n        load_aria_model()\n\n    print(\"Processing image with ARIA model...\")\n    image = Image.open(image_path).convert(\"RGB\")\n    messages = [\n        {\"role\": \"user\", \"content\": [\n            {\"text\": None, \"type\": \"image\"},\n            {\"text\": question, \"type\": \"text\"},\n        ]}\n    ]\n\n    text = aria_processor.apply_chat_template(messages, add_generation_prompt=True)\n    inputs = aria_processor(text=text, images=image, return_tensors=\"pt\")\n    inputs[\"pixel_values\"] = inputs[\"pixel_values\"].to(aria_model.dtype)\n    inputs = {k: v.to(aria_model.device) for k, v in inputs.items()}\n\n    with torch.inference_mode(), torch.cuda.amp.autocast(dtype=torch.bfloat16):\n        output = aria_model.generate(\n            **inputs,\n            max_new_tokens=1024,\n            stop_strings=[\"<|im_end|>\"],\n            tokenizer=aria_processor.tokenizer,\n            do_sample=True,\n            temperature=0.9,\n        )\n        output_ids = output[0][inputs[\"input_ids\"].shape[1]:]\n        result = aria_processor.decode(output_ids, skip_special_tokens=True)\n\n    print(\"Image processing complete.\")\n    return result\n```\n\n### Summary of Changes\n1. **Declared Global Variables**: `aria_model` and `aria_processor` are declared as global variables.\n2. **Updated `load_aria_model` Function**: Ensures that `aria_model` and `aria_processor` are properly initialized.\n3. **Updated `unload_aria_model` Function**: Ensures that `aria_model` and `aria_processor` are properly unloaded and memory is cleared.\n4. **Updated `process_with_aria_model` Function**: Ensures that `aria_model` and `aria_processor` are correctly referenced and used.\n\nThese changes should resolve the `NameError: name 'aria_model' is not defined` error and ensure that the ARIA model works correctly."
        ]
    ],
    "visible": [
        [
            "",
            "How can I help you today?"
        ],
        [
            "I have this code called LucidVision.py.  I want to integrate two new models GOT-OCR and Aria.  Both of these models are unique to the LucidVision.py code, however I have them successfully integrated into code called script.py\n\nGOT-OCR is an ocr model and does not accept user questions, please note that in the script.py code; and Aria is a large model that cannot be loaded onto one gpu like the other lucid vision models, note this in the script.py code.\n\nLucidVision.py:\n```\n# pip install pexpect\nimport json\nimport re\nfrom datetime import datetime  # Import datetime for timestamp generation\nfrom pathlib import Path\n\nimport gradio as gr\nimport torch\nfrom PIL import Image\nfrom deepseek_vl.models import VLChatProcessor\nfrom deepseek_vl.utils.io import load_pil_images as load_pil_images_for_deepseek\nfrom transformers import AutoModelForCausalLM, AutoModel, AutoTokenizer, AutoProcessor, \\\n    PaliGemmaForConditionalGeneration\n\nmodel_names = [&quot;phiVision&quot;, &quot;DeepSeek&quot;, &quot;paligemma&quot;, &quot;paligemma_cpu&quot;, &quot;minicpm_llama3&quot;, &quot;bunny&quot;]\n\n\n# Load configuration settings from a JSON file\ndef load_config():\n    with open(Path(__file__).parent / &quot;config.json&quot;, &quot;r&quot;) as config_file:\n        # Read and parse the JSON configuration file\n        config = json.load(config_file)\n    return config\n\n\n# Load the configuration settings at the module level\nconfig = load_config()\n\n# Define the model ID for PhiVision using the configuration setting\nphiVision_model_id = config[&quot;phiVision_model_id&quot;]\n\n# Define the model ID for PaliGemma using the configuration setting\npaligemma_model_id = config[&quot;paligemma_model_id&quot;]\n\nminicpm_llama3_model_id = config[&quot;minicpm_llama3_model_id&quot;]\n\nbunny_model_id = config[&quot;bunny_model_id&quot;]\n\ncuda_device = config[&quot;cuda_visible_devices&quot;]\n\nselected_vision_model = config[&quot;default_vision_model&quot;]\n\n# Global variable to store the file path of the selected image\nselected_image_path = None\n\n# Define the directory where the image files will be saved\n# This path is loaded from the configuration file\nimage_history_dir = Path(config[&quot;image_history_dir&quot;])\n# Ensure the directory exists, creating it if necessary\nimage_history_dir.mkdir(parents=True, exist_ok=True)\n\nglobal phiVision_model, phiVision_processor\nglobal minicpm_llama_model, minicpm_llama_tokenizer\nglobal paligemma_model, paligemma_processor\nglobal paligemma_cpu_model, paligemma_cpu_processor\nglobal deepseek_processor, deepseek_tokenizer, deepseek_gpt\nglobal bunny_model, bunny_tokenizer\n\n\n# Function to generate a timestamped filename for saved images\ndef get_timestamped_filename(extension=&quot;.png&quot;):\n    # Generate a timestamp in the format YYYYMMDD_HHMMSS\n    timestamp = datetime.now().strftime(&quot;%Y%m%d_%H%M%S&quot;)\n    # Return a formatted file name with the timestamp\n    return f&quot;image_{timestamp}{extension}&quot;\n\n\n# Function to modify the user input before it is processed by the LLM\ndef input_modifier(user_input, state):\n    global selected_image_path\n    # Check if an image has been selected and stored in the global variable\n    if selected_image_path:\n        # Construct the message with the &quot;File location&quot; trigger phrase and the image file path\n        image_info = f&quot;File location: {selected_image_path}&quot;\n        # Combine the user input with the image information, separated by a newline for clarity\n        combined_input = f&quot;{user_input}\\n\\n{image_info}&quot;\n        # Reset the selected image path to None after processing\n        selected_image_path = None\n        return combined_input\n    # If no image is selected, return the user input as is\n    return user_input\n\n\n# Function to handle image upload and store the file path\ndef save_and_print_image_path(image):\n    global selected_image_path\n    if image is not None:\n        # Generate a unique timestamped filename for the image\n        file_name = get_timestamped_filename()\n        # Construct the full file path for the image\n        file_path = image_history_dir / file_name\n        # Save the uploaded image to the specified directory\n        image.save(file_path, format=&#x27;PNG&#x27;)\n        print(f&quot;Image selected: {file_path}&quot;)\n        # Update the global variable with the new image file path\n        selected_image_path = file_path\n    else:\n        # Print a message if no image is selected\n        print(&quot;No image selected yet.&quot;)\n\n\n# Function to create the Gradio UI components with the new direct vision model interaction elements\ndef ui():\n    # Create an image input component for the Gradio UI\n    image_input = gr.Image(label=&quot;Select an Image&quot;, type=&quot;pil&quot;, source=&quot;upload&quot;)\n    # Set up the event that occurs when an image is uploaded\n    image_input.change(\n        fn=save_and_print_image_path,\n        inputs=image_input,\n        outputs=None\n    )\n\n    # Create a text field for user input to the vision model\n    user_input_to_vision_model = gr.Textbox(label=&quot;Type your question or prompt for the vision model&quot;, lines=2,\n                                            placeholder=&quot;Enter your text here...&quot;)\n\n    # Create a button to trigger the vision model processing\n    vision_model_button = gr.Button(value=&quot;Ask Vision Model&quot;)\n\n    # Create a text field to display the vision model&#x27;s response\n    vision_model_response_output = gr.Textbox(\n        label=&quot;Vision Model Response&quot;,\n        lines=5,\n        placeholder=&quot;Response will appear here...&quot;\n    )\n\n    # Add radio buttons for vision model selection\n    vision_model_selection = gr.Radio(\n        choices=model_names,\n        # Added &quot;paligemma_cpu&quot; as a choice\n        value=config[&quot;default_vision_model&quot;],\n        label=&quot;Select Vision Model&quot;\n    )\n\n    # Add an event handler for the radio button selection\n    vision_model_selection.change(\n        fn=update_vision_model,\n        inputs=vision_model_selection,\n        outputs=None\n    )\n\n    cuda_devices_input = gr.Textbox(\n        value=cuda_device,\n        label=&quot;CUDA Device ID&quot;,\n        max_lines=1\n    )\n\n    cuda_devices_input.change(\n        fn=update_cuda_device,\n        inputs=cuda_devices_input,\n        outputs=None\n    )\n\n    # Set up the event that occurs when the vision model button is clicked\n    vision_model_button.click(\n        fn=process_with_vision_model,\n        inputs=[user_input_to_vision_model, image_input, vision_model_selection],\n        # Pass the actual gr.Image component\n        outputs=vision_model_response_output\n    )\n\n    # Return a column containing the UI components\n    return gr.Column(\n        [\n            image_input,\n            user_input_to_vision_model,\n            vision_model_button,\n            vision_model_response_output,\n            vision_model_selection\n        ]\n    )\n\n\n# Function to load the PaliGemma CPU model and processor\ndef load_paligemma_cpu_model():\n    global paligemma_cpu_model, paligemma_cpu_processor\n    paligemma_cpu_model = PaliGemmaForConditionalGeneration.from_pretrained(\n        paligemma_model_id,\n    ).eval()\n    paligemma_cpu_processor = AutoProcessor.from_pretrained(paligemma_model_id)\n    print(&quot;PaliGemma CPU model loaded on-demand.&quot;)\n\n\n# Function to unload the PaliGemma CPU model and processor\ndef unload_paligemma_cpu_model():\n    global paligemma_cpu_model, paligemma_cpu_processor\n    if paligemma_cpu_model is not None:\n        # Delete the model and processor instances\n        del paligemma_cpu_model\n        del paligemma_cpu_processor\n        print(&quot;PaliGemma CPU model unloaded.&quot;)\n\n    # Global variable to store the selected vision model\n\n\n# Function to update the selected vision model and load the corresponding model\ndef update_vision_model(model_name):\n    global selected_vision_model\n    selected_vision_model = model_name\n    return model_name\n\n\ndef update_cuda_device(device):\n    global cuda_device\n    print(f&quot;Cuda device set to index = {device}&quot;)\n    cuda_device = int(device)\n    return cuda_device\n\n\n# Main entry point for the Gradio interface\nif __name__ == &quot;__main__&quot;:\n    # Launch the Gradio interface with the specified UI components\n    gr.Interface(\n        fn=ui,\n        inputs=None,\n        outputs=&quot;ui&quot;\n    ).launch()\n\n# Define a regular expression pattern to match the &quot;File location&quot; trigger phrase\nfile_location_pattern = re.compile(r&quot;File location: (.+)$&quot;, re.MULTILINE)\n# Define a regular expression pattern to match and remove unwanted initial text\nunwanted_initial_text_pattern = re.compile(r&quot;.*?prod\\(dim=0\\)\\r\\n&quot;, re.DOTALL)\n\n# Define a regular expression pattern to match and remove unwanted prefixes from DeepSeek responses\n# This pattern should be updated to match the new, platform-independent file path format\nunwanted_prefix_pattern = re.compile(\n    r&quot;^&quot; + re.escape(str(image_history_dir)) + r&quot;[^ ]+\\.png\\s*Assistant: &quot;,\n    re.MULTILINE\n)\n\n\n# Function to load the PhiVision model and processor\ndef load_phi_vision_model():\n    global phiVision_model, phiVision_processor, cuda_device\n    # Load the PhiVision model and processor on-demand, specifying the device map\n    phiVision_model = AutoModelForCausalLM.from_pretrained(\n        phiVision_model_id,\n        device_map={&quot;&quot;: cuda_device},  # Use the specified CUDA device(s)\n        trust_remote_code=True,\n        torch_dtype=&quot;auto&quot;\n    )\n    phiVision_processor = AutoProcessor.from_pretrained(\n        phiVision_model_id,\n        trust_remote_code=True\n    )\n    print(&quot;PhiVision model loaded on-demand.&quot;)\n\n\n# Function to unload the PhiVision model and processor\ndef unload_phi_vision_model():\n    global phiVision_model, phiVision_processor\n    if phiVision_model is not None:\n        # Delete the model and processor instances\n        del phiVision_model\n        del phiVision_processor\n        # Clear the CUDA cache to free up VRAM\n        torch.cuda.empty_cache()\n        print(&quot;PhiVision model unloaded.&quot;)\n\n\n# Function to load the MiniCPM-Llama3 model and tokenizer\ndef load_minicpm_llama_model():\n    global minicpm_llama_model, minicpm_llama_tokenizer, cuda_device\n    if &quot;int4&quot; in minicpm_llama3_model_id:\n        # Load the 4-bit quantized model and tokenizer\n        minicpm_llama_model = AutoModel.from_pretrained(\n            minicpm_llama3_model_id,\n            device_map={&quot;&quot;: cuda_device},\n            trust_remote_code=True,\n            torch_dtype=torch.float16  # Use float16 as per the example code for 4-bit models\n        ).eval()\n        minicpm_llama_tokenizer = AutoTokenizer.from_pretrained(\n            minicpm_llama3_model_id,\n            trust_remote_code=True\n        )\n        # Print a message indicating that the 4-bit model is loaded\n        print(&quot;MiniCPM-Llama3 4-bit quantized model loaded on-demand.&quot;)\n    else:\n        # Load the standard model and tokenizer\n        minicpm_llama_model = AutoModel.from_pretrained(\n            minicpm_llama3_model_id,\n            device_map={&quot;&quot;: cuda_device},  # Use the specified CUDA device\n            trust_remote_code=True,\n            torch_dtype=torch.bfloat16\n        ).eval()\n        minicpm_llama_tokenizer = AutoTokenizer.from_pretrained(\n            minicpm_llama3_model_id,\n            trust_remote_code=True\n        )\n        print(&quot;MiniCPM-Llama3 standard model loaded on-demand.&quot;)\n\n\ndef unload_minicpm_llama_model():\n    global minicpm_llama_model, minicpm_llama_tokenizer\n    if minicpm_llama_model is not None:\n        del minicpm_llama_model\n        del minicpm_llama_tokenizer\n        torch.cuda.empty_cache()\n        print(&quot;MiniCPM-Llama3 model unloaded.&quot;)\n\n\n# Function to load the PaliGemma model and processor\ndef load_paligemma_model():\n    global paligemma_model, paligemma_processor, cuda_device\n    # Load the PaliGemma model and processor on-demand, specifying the device map\n    paligemma_model = PaliGemmaForConditionalGeneration.from_pretrained(\n        paligemma_model_id,\n        device_map={&quot;&quot;: cuda_device},  # Use the specified CUDA device(s)\n        torch_dtype=torch.bfloat16,\n        revision=&quot;bfloat16&quot;,\n    ).eval()\n    paligemma_processor = AutoProcessor.from_pretrained(paligemma_model_id)\n    print(&quot;PaliGemma model loaded on-demand.&quot;)\n\n\n# Function to unload the PaliGemma model and processor\ndef unload_paligemma_model():\n    global paligemma_model, paligemma_processor\n    if paligemma_model is not None:\n        # Delete the model and processor instances\n        del paligemma_model\n        del paligemma_processor\n        # Clear the CUDA cache to free up VRAM\n        torch.cuda.empty_cache()\n        print(&quot;PaliGemma model unloaded.&quot;)\n\n\ndef load_deepseek_model():\n    global deepseek_processor, deepseek_tokenizer, deepseek_gpt, cuda_device\n    deepseek_processor = VLChatProcessor.from_pretrained(config[&quot;deepseek_vl_model_id&quot;])\n    deepseek_tokenizer = deepseek_processor.tokenizer\n    deepseek_gpt = AutoModelForCausalLM.from_pretrained(\n        config[&quot;deepseek_vl_model_id&quot;],\n        device_map={&quot;&quot;: cuda_device},\n        trust_remote_code=True,\n        torch_dtype=torch.bfloat16\n    ).to(torch.bfloat16).cuda().eval()\n    print(&quot;DeepSeek model loaded on-demand.&quot;)\n\n\ndef unload_deepseek_model():\n    global deepseek_processor, deepseek_tokenizer, deepseek_gpt\n    if deepseek_processor is not None:\n        del deepseek_gpt\n        del deepseek_tokenizer\n        del deepseek_processor\n        print(&quot;DeepSeek model unloaded.&quot;)\n    torch.cuda.empty_cache()\n\n\ndef load_bunny_model():\n    global bunny_model, bunny_tokenizer, cuda_device\n    torch.cuda.set_device(cuda_device)  # Set default device before loading models\n    bunny_model = AutoModelForCausalLM.from_pretrained(\n        bunny_model_id,\n        torch_dtype=torch.bfloat16,\n        device_map={&quot;&quot;: cuda_device},  # Use the specified CUDA device\n        trust_remote_code=True\n    ).to(torch.bfloat16).cuda()\n    bunny_tokenizer = AutoTokenizer.from_pretrained(\n        bunny_model_id,\n        trust_remote_code=True\n    )\n    print(&quot;Bunny model loaded on-demand.&quot;)\n\n\ndef unload_bunny_model():\n    global bunny_model, bunny_tokenizer\n    if bunny_model is not None:\n        del bunny_model, bunny_tokenizer\n        print(&quot;Bunny model unloaded.&quot;)\n    torch.cuda.empty_cache()\n\n\n# Function to modify the output from the LLM before it is displayed to the user\ndef output_modifier(output, state, is_chat=False):\n    global cuda_device\n    # Search for the &quot;File location&quot; trigger phrase in the LLM&#x27;s output\n    file_location_matches = file_location_pattern.findall(output)\n    if file_location_matches:\n        # Extract the first match (assuming only one file location per output)\n        file_path = file_location_matches[0]\n        # Extract the questions for the vision model\n        questions_section, _ = output.split(f&quot;File location: {file_path}&quot;, 1)\n        # Remove all newlines from the questions section and replace them with spaces\n        questions = &quot; &quot;.join(questions_section.strip().splitlines())\n\n        # Initialize an empty response string\n        vision_model_response = &quot;&quot;\n\n        # Check which vision model is currently selected\n        if selected_vision_model == &quot;phiVision&quot;:\n            vision_model_response = generate_phi_vision(file_path, questions)\n\n        elif selected_vision_model == &quot;DeepSeek&quot;:\n            vision_model_response = generate_deepseek(file_path, questions)\n\n        elif selected_vision_model == &quot;paligemma&quot;:\n            vision_model_response = generate_paligemma(file_path, questions)\n\n        elif selected_vision_model == &quot;paligemma_cpu&quot;:\n            vision_model_response = generate_paligemma_cpu(file_path, questions)\n\n        elif selected_vision_model == &quot;minicpm_llama3&quot;:\n            vision_model_response = generate_minicpm_llama3(file_path, questions)\n\n        elif selected_vision_model == &quot;bunny&quot;:\n            vision_model_response = generate_bunny(file_path, questions)\n\n        # Append the vision model&#x27;s responses to the output\n        output_with_responses = f&quot;{output}\\n\\nVision Model Responses:\\n{vision_model_response}&quot;\n        return output_with_responses\n    # If no file location is found, return the output as is\n    return output\n\n\n# Function to generate a response using the MiniCPM-Llama3 model\ndef generate_minicpm_llama3(file_path, questions):\n    global cuda_device\n    try:\n        load_minicpm_llama_model()\n        image = Image.open(file_path).convert(&quot;RGB&quot;)\n        messages = [\n            {&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: f&quot;{questions}&quot;}\n        ]\n        # Define the generation arguments\n        generation_args = {\n            &quot;max_new_tokens&quot;: 896,\n            &quot;repetition_penalty&quot;: 1.05,\n            &quot;num_beams&quot;: 3,\n            &quot;top_p&quot;: 0.8,\n            &quot;top_k&quot;: 1,\n            &quot;temperature&quot;: 0.7,\n            &quot;sampling&quot;: True,\n        }\n        if &quot;int4&quot; in minicpm_llama3_model_id:\n            # Disable streaming for the 4-bit model\n            generation_args[&quot;stream&quot;] = False\n            # Use the model.chat method with streaming enabled\n            vision_model_response = &quot;&quot;\n            for new_text in minicpm_llama_model.chat(\n                    image=image,\n                    msgs=messages,\n                    tokenizer=minicpm_llama_tokenizer,\n                    **generation_args\n            ):\n                vision_model_response += new_text\n                print(new_text, flush=True, end=&#x27;&#x27;)\n        else:\n            minicpm_llama_model.to(f&quot;cuda:{cuda_device}&quot;)\n            vision_model_response = minicpm_llama_model.chat(\n                image=image,\n                msgs=messages,\n                tokenizer=minicpm_llama_tokenizer,\n                **generation_args\n            )\n            return vision_model_response\n    finally:\n        unload_minicpm_llama_model()\n\n\n# Function to process the user&#x27;s input text and selected image with the vision model\ndef process_with_vision_model(user_input, image, selected_model):\n    global cuda_device\n    # Save the uploaded image to the specified directory with a timestamp\n    file_name = get_timestamped_filename()\n    file_path = image_history_dir / file_name\n    image.save(file_path, format=&#x27;PNG&#x27;)\n    print(f&quot;Image processed: {file_path}&quot;)\n\n    # Initialize an empty response string\n    vision_model_response = &quot;&quot;\n\n    # Check which vision model is currently selected\n    if selected_model == &quot;phiVision&quot;:\n        vision_model_response = generate_phi_vision(file_path, user_input)\n\n    elif selected_model == &quot;DeepSeek&quot;:\n        vision_model_response = generate_deepseek(file_path, user_input)\n\n    elif selected_model == &quot;paligemma&quot;:\n        vision_model_response = generate_paligemma(file_path, user_input)\n\n    elif selected_model == &quot;paligemma_cpu&quot;:\n        vision_model_response = generate_paligemma_cpu(file_path, user_input)\n\n    elif selected_model == &quot;minicpm_llama3&quot;:\n        vision_model_response = generate_minicpm_llama3(file_path, user_input)\n\n    elif selected_model == &quot;bunny&quot;:\n        vision_model_response = generate_bunny(file_path, user_input)\n\n    # Return the cleaned-up response from the vision model\n    return vision_model_response\n\n\ndef generate_paligemma_cpu(file_path, user_input):\n    try:\n        # Load the PaliGemma CPU model and processor on-demand\n        load_paligemma_cpu_model()\n        # Load the saved image using PIL\n        with Image.open(file_path) as img:\n            # Prepare the prompt for the PaliGemma CPU model using the user&#x27;s question\n            prompt = user_input\n            model_inputs = paligemma_cpu_processor(text=prompt, images=img, return_tensors=&quot;pt&quot;)\n            input_len = model_inputs[&quot;input_ids&quot;].shape[-1]\n            # Generate the response using the PaliGemma CPU model\n            with torch.inference_mode():\n                generation = paligemma_cpu_model.generate(\n                    **model_inputs,\n                    max_new_tokens=100,\n                    do_sample=True  # Set to True for sampling-based generation\n                )\n                generation = generation[0][input_len:]\n                vision_model_response = paligemma_cpu_processor.decode(generation, skip_special_tokens=True)\n        # Unload the PaliGemma CPU model and processor after generating the response\n        return vision_model_response\n    finally:\n        unload_paligemma_cpu_model()\n\n\ndef generate_paligemma(file_path, user_input):\n    try:\n        # Load the PaliGemma model and processor on-demand\n        load_paligemma_model()\n        # Load the saved image using PIL\n        with Image.open(file_path) as img:\n            # Prepare the prompt for the PaliGemma model using the user&#x27;s question\n            model_inputs = paligemma_processor(text=user_input, images=img, return_tensors=&quot;pt&quot;).to(\n                f&quot;cuda:{cuda_device}&quot;)\n            input_len = model_inputs[&quot;input_ids&quot;].shape[-1]\n            # Generate the response using the PaliGemma model\n            with torch.inference_mode():\n                generation = paligemma_model.generate(\n                    **model_inputs,\n                    max_new_tokens=100,\n                    do_sample=True  # Set to True for sampling-based generation\n                )\n                generation = generation[0][input_len:]\n                vision_model_response = paligemma_processor.decode(generation, skip_special_tokens=True)\n        # Unload the PaliGemma model and processor after generating the response\n        return vision_model_response\n    finally:\n        unload_paligemma_model()\n\n\ndef generate_phi_vision(file_path, user_input):\n    global cuda_device\n    try:\n        # Load the PhiVision model and processor on-demand\n        load_phi_vision_model()\n        # Load the saved image using PIL\n        with Image.open(file_path) as img:\n            # Prepare the prompt for the PhiVision model\n            messages = [\n                {&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: f&quot;&lt;|image_1|&gt;\\n{user_input}&quot;}\n            ]\n            prompt = phiVision_processor.tokenizer.apply_chat_template(\n                messages, tokenize=False, add_generation_prompt=True\n            )\n            # Extract the CUDA_VISIBLE_DEVICES setting from the config file\n            # cuda_devices = config[&quot;cuda_visible_devices&quot;]\n            # Convert the CUDA_VISIBLE_DEVICES string to an integer (assuming a single device for simplicity)\n            # cuda_device_index = int(cuda_devices)\n\n            # Prepare the model inputs and move them to the specified CUDA device\n            inputs = phiVision_processor(prompt, [img], return_tensors=&quot;pt&quot;).to(f&quot;cuda:{cuda_device}&quot;)\n            # Define the generation arguments\n            generation_args = {\n                &quot;max_new_tokens&quot;: 500,\n                &quot;temperature&quot;: 1.0,\n                &quot;do_sample&quot;: True,  # Set to True for sampling-based generation\n                # &quot;min_p&quot;: 0.95,  # Optionally set a minimum probability threshold\n            }\n            # Generate the response using the PhiVision model\n            generate_ids = phiVision_model.generate(\n                **inputs,\n                eos_token_id=phiVision_processor.tokenizer.eos_token_id,\n                **generation_args\n            )\n            # Remove input tokens from the generated IDs\n            generate_ids = generate_ids[:, inputs[&#x27;input_ids&#x27;].shape[1]:]\n            # Decode the generated IDs to get the text response\n            vision_model_response = phiVision_processor.batch_decode(\n                generate_ids,\n                skip_special_tokens=True,\n                clean_up_tokenization_spaces=False\n            )[0]\n        # Unload the PhiVision model and processor after generating the response\n        return vision_model_response\n    finally:\n        unload_phi_vision_model()\n\n\ndef generate_deepseek(file_path, user_input):\n    try:\n        load_deepseek_model()\n        conversation = [\n            {\n                &quot;role&quot;: &quot;User&quot;,\n                &quot;content&quot;: f&quot;&lt;image_placeholder&gt;{user_input}&quot;,\n                &quot;images&quot;: [f&quot;{file_path}&quot;]\n            }, {\n                &quot;role&quot;: &quot;Assistant&quot;,\n                &quot;content&quot;: &quot;&quot;\n            }\n        ]\n        print(conversation)\n        pil_images = load_pil_images_for_deepseek(conversation)\n        prepare_inputs = deepseek_processor(\n            conversations=conversation,\n            images=pil_images,\n            force_batchify=True\n        ).to(deepseek_gpt.device)\n        input_embeds = deepseek_gpt.prepare_inputs_embeds(**prepare_inputs)\n        outputs = deepseek_gpt.language_model.generate(\n            inputs_embeds=input_embeds,\n            attention_mask=prepare_inputs.attention_mask,\n            pad_token_id=deepseek_tokenizer.eos_token_id,\n            bos_token_id=deepseek_tokenizer.bos_token_id,\n            eos_token_id=deepseek_tokenizer.eos_token_id,\n            max_new_tokens=512,\n            do_sample=False,\n            use_cache=True\n        )\n        return deepseek_tokenizer.decode(outputs[0].cpu().tolist(), skip_special_tokens=True)\n    finally:\n        unload_deepseek_model()\n\n\ndef generate_bunny(file_path, user_input):\n    global cuda_device\n    try:\n        load_bunny_model()\n        with Image.open(file_path) as image:\n            text = f&quot;A chat between a curious user and an artificial intelligence assistant. The assistant gives helpful, detailed, and polite answers to the user&#x27;s questions. USER: &lt;image&gt;\\n{user_input} ASSISTANT:&quot;\n            text_chunks = [bunny_tokenizer(chunk).input_ids for chunk in text.split(&#x27;&lt;image&gt;&#x27;)]\n            input_ids = torch.tensor(text_chunks[0] + [-200] + text_chunks[1][1:], dtype=torch.long).unsqueeze(0).to(\n                f&quot;cuda:{cuda_device}&quot;)\n            image_tensor = bunny_model.process_images(\n                [image],\n                bunny_model.config\n            ).to(\n                dtype=bunny_model.dtype,\n                device=bunny_model.device\n            )\n            output_ids = bunny_model.generate(\n                input_ids,\n                images=image_tensor,\n                max_new_tokens=896,\n                use_cache=True,\n                repetition_penalty=1.0\n            )[0]\n            return bunny_tokenizer.decode(output_ids[input_ids.shape[1]:], skip_special_tokens=True).strip()\n    finally:\n        unload_bunny_model()\n\n\n# Function to modify the chat history before it is used for text generation\ndef history_modifier(history):\n    # Extract all entries from the &quot;internal&quot; history\n    internal_entries = history[&quot;internal&quot;]\n    # Iterate over the &quot;internal&quot; history entries\n    for internal_index, internal_entry in enumerate(internal_entries):\n        # Extract the text content of the internal entry\n        internal_text = internal_entry[1]\n        # Search for the &quot;File location&quot; trigger phrase in the internal text\n        file_location_matches = file_location_pattern.findall(internal_text)\n        if file_location_matches:\n            # Iterate over each match found in the &quot;internal&quot; entry\n            for file_path in file_location_matches:\n                # Construct the full match string including the trigger phrase\n                full_match_string = f&quot;File location: {file_path}&quot;\n                # Search for the exact same string in the &quot;visible&quot; history\n                for visible_entry in history[&quot;visible&quot;]:\n                    # Extract the text content of the visible entry\n                    visible_text = visible_entry[1]\n                    # If the &quot;visible&quot; entry contains the full match string\n                    if full_match_string in visible_text:\n                        # Split the &quot;visible&quot; text at the full match string\n                        _, after_match = visible_text.split(full_match_string, 1)\n                        # Find the position where the &quot;.png&quot; part ends in the &quot;internal&quot; text\n                        png_end_pos = internal_text.find(file_path) + len(file_path)\n                        # If the &quot;.png&quot; part is found and there is content after it\n                        if png_end_pos &lt; len(internal_text) and internal_text[png_end_pos] == &quot;\\n&quot;:\n                            # Extract the existing content after the &quot;.png&quot; part in the &quot;internal&quot; text\n                            _ = internal_text[png_end_pos:]\n                            # Replace the existing content after the &quot;.png&quot; part in the &quot;internal&quot; text\n                            # with the corresponding content from the &quot;visible&quot; text\n                            new_internal_text = internal_text[:png_end_pos] + after_match\n                            # Update the &quot;internal&quot; history entry with the new text\n                            history[&quot;internal&quot;][internal_index][1] = new_internal_text\n                        # If there is no content after the &quot;.png&quot; part in the &quot;internal&quot; text,\n                        # append the content from the &quot;visible&quot; text directly\n                        else:\n                            # Append the content after the full match string from the &quot;visible&quot; text\n                            history[&quot;internal&quot;][internal_index][1] += after_match\n    return history\n```\n\nThis is the config file for LucidVision.py:\n```\n{\n    &quot;image_history_dir&quot;: &quot;/home/myself/Desktop/OobV115/text-generation-webui/extensions/Lucid_Vision/Image_History/&quot;,\n    &quot;cuda_visible_devices&quot;: 0,\n    &quot;default_vision_model&quot;: &quot;phiVision&quot;,\n    &quot;phiVision_model_id&quot;: &quot;/home/myself/Desktop/phiVision/phivisionMay23/Phi-3-vision-128k-instruct/&quot;,\n    &quot;paligemma_model_id&quot;: &quot;/home/myself/Desktop/paligemma/paligemmaMay23/paligemma-3b-ft-cococap-448/&quot;,\n    &quot;paligemma_cpu_model_id&quot;:&quot;/home/myself/Desktop/paligemma/paligemmaMay23/paligemma-3b-ft-cococap-448/&quot;,\n    &quot;minicpm_llama3_model_id&quot;: &quot;/home/myself/Desktop/miniCPM_llava3V/MiniCPM-V-2_6/&quot;,\n    &quot;deepseek_vl_model_id&quot;: &quot;/home/myself/Desktop/DeepSeekVL/DeepSeek-VL/deepseek-vl-7b-chat/&quot;,\n    &quot;bunny_model_id&quot;: &quot;/home/myself/Desktop/BunnyVision/Bunny-v1_1-Llama-3-8B-V/&quot;,\n    &quot;got_ocr_model_id&quot;: &quot;/home/myself/Desktop/GOT_OCR/ModelGOT-OCR2_0/&quot;,\n    &quot;aria_model_id&quot;: &quot;/home/myself/Desktop/Aria/&quot;\n}\n```\n\nPlease pay attention this piece of code called script.py uses both of the GOT-OCR and aria models, use the knowledge from script.py to update the necessary components of LucidVision.py.\n\nPlease write out only the updated or new functions for the LucidVision.py file please.\n\nscript.py\n```\nimport os\n#os.environ[&quot;CUDA_VISIBLE_DEVICES&quot;] = &quot;0&quot;\nimport gradio as gr\nimport json\nimport pyautogui\nimport screeninfo\nfrom transformers import Owlv2Processor, Owlv2ForObjectDetection, AutoModel, AutoTokenizer, AutoProcessor, PaliGemmaForConditionalGeneration, AutoModelForCausalLM\nfrom PIL import Image, ImageDraw\nimport torch\nimport os\nimport shutil\nimport re  # Import the re module for regular expression operations\nimport json\nimport time\nimport threading\nimport pdf2image  # Add this import for PDF to PNG conversion\nimport uuid\nimport tempfile\nimport time\nimport shutil\nfrom pathlib import Path\nimport time\nimport pypdfium2  # Needs to be at the top to avoid warnings\nimport os\nimport gradio as gr\nimport spaces\nfrom transformers import AutoModel, AutoTokenizer\nfrom PIL import Image\nimport numpy as np\nimport base64\nimport io\nimport uuid\nimport tempfile\nimport subprocess\nimport time\nimport shutil\nfrom pathlib import Path\nos.environ[&quot;PYTORCH_ENABLE_MPS_FALLBACK&quot;] = &quot;1&quot;  # For some reason, transformers decided to use .isin for a simple op, which is not supported on MPS\nimport gc\nfrom marker.convert import convert_single_pdf\nfrom marker.logger import configure_logging\nfrom marker.models import load_all_models\nfrom marker.output import save_markdown\n\nconfigure_logging()\n\noob_tasks_file = &quot;extensions/Lucid_Autonomy/oob_tasks.json&quot;\n\n# Configurable variables\nMONITOR_INDEX = 0  # Index of the monitor to capture (0 for the first monitor, 1 for the second monitor, etc.)\nTEXT_QUERIES = &quot;colored hyperlink text,clickable icons,text bar field,clickable UI buttons,UI tabs,Interactive UI Elements,blue text hyperlink&quot;  # Comma-separated text queries for object detection\nSCORE_THRESHOLD = 0.24  # Score threshold for filtering low-probability predictions\nVISION_MODEL_QUESTION = &quot;Keep your response to less than 5 sentences: What is the text in this image or what does this image describe? The AI is aiding in helping those with visual handicaps so the AI will focus on providing all of the relevant information for the listener.&quot;\nFULL_IMAGE_VISION_MODEL_QUESTION = &quot;This is a computer screenshot, identify all article text if the screen is displaying an article.  Describe what you see in this image, if you see UI elements describe them and their general location and if you see text read the text verbatim.  Describe the general theme and context of the image. You are aiding in helping those with visual handicaps so you need to try and focus on providing all of the relevant text on a screen and contextualizing it for the listener.&quot;\n\n# Use GPU if available\ndevice = 0\n\n# Global variables for models\nowlv2_model = None\nowlv2_processor = None\nminicpm_llama_model = None\nminicpm_llama_tokenizer = None\nchartgemma_model = None\nchartgemma_processor = None\ngot_ocr_model = None\ngot_ocr_tokenizer = None\n\nVISION_MODEL_ID = &quot;/home/myself/Desktop/miniCPM_llava3V/MiniCPM-V-2_6/&quot;\nGOT_OCR_MODEL_PATH = &#x27;/home/myself/Desktop/GOT_OCR/ModelGOT-OCR2_0/&#x27;\n\n# Global variable to store the file path of the selected image\nselected_image_path = None\nselected_markdown_path = None\n\n# Function to set the CUDA_VISIBLE_DEVICES environment variable\ndef set_cuda_visible_devices(device_id):\n    os.environ[&quot;CUDA_VISIBLE_DEVICES&quot;] = str(device_id)\n\n# Function to reset the CUDA_VISIBLE_DEVICES environment variable\ndef reset_cuda_visible_devices():\n    os.environ[&quot;CUDA_VISIBLE_DEVICES&quot;] = &quot;&quot;\n\ndef process_marker_file(filename, output_folder, max_pages=None, start_page=None, langs=None, batch_multiplier=2, ocr_all_pages=False):\n    os.environ[&quot;CUDA_VISIBLE_DEVICES&quot;] = &quot;0&quot;\n    torch.cuda.set_device(0)  # Explicitly set CUDA device\n    \n    model_lst = load_all_models(device=&quot;cuda:0&quot;)\n    start = time.time()\n\n    full_text, images, out_meta = convert_single_pdf(filename, model_lst, max_pages=max_pages, langs=langs, batch_multiplier=batch_multiplier, start_page=start_page, ocr_all_pages=ocr_all_pages)\n\n    fname = os.path.basename(filename)\n    subfolder_path = save_markdown(output_folder, fname, full_text, images, out_meta)\n\n    print(f&quot;Saved markdown to the {subfolder_path} folder&quot;)\n    print(f&quot;Total time: {time.time() - start}&quot;)\n\n    return subfolder_path\n\ndef generate_image_list(folder_path):\n    &quot;&quot;&quot;\n    Generates a list of image files in the specified folder.\n\n    Args:\n        folder_path (str): The path to the folder containing the image files.\n\n    Returns:\n        list: A list of image file paths.\n    &quot;&quot;&quot;\n    image_list = []\n    for root, dirs, files in os.walk(folder_path):\n        for file in files:\n            if file.endswith(&quot;.png&quot;):\n                image_list.append(os.path.join(root, file))\n    return image_list\n\ndef match_image_references(md_file_path, image_list):\n    &quot;&quot;&quot;\n    Matches image references in the markdown file with the actual image files.\n\n    Args:\n        md_file_path (str): The path to the markdown file.\n        image_list (list): A list of image file paths.\n\n    Returns:\n        dict: A dictionary mapping image references to their disk locations.\n    &quot;&quot;&quot;\n    image_references = {}\n    with open(md_file_path, &#x27;r&#x27;) as md_file:\n        content = md_file.read()\n        for image_path in image_list:\n            image_name = os.path.basename(image_path)\n            if image_name in content:\n                image_references[image_name] = image_path\n    return image_references\n\ndef add_disk_location_info(md_file_path, image_references):\n    &quot;&quot;&quot;\n    Adds disk location information and vision model response to the markdown file for each image reference.\n\n    Args:\n        md_file_path (str): The path to the markdown file.\n        image_references (dict): A dictionary mapping image references to their disk locations.\n    &quot;&quot;&quot;\n    with open(md_file_path, &#x27;r&#x27;) as md_file:\n        content = md_file.read()\n\n        # Load the miniCPM-lama3-v-2_5 model\n        load_minicpm_llama_model()\n\n    for image_name, image_path in image_references.items():\n        # Process the image with the vision model to identify the image type\n        question = &quot;Identify if this image is a chart, table, equation, graph, bar chart, illustration, drawing, or picture. Respond with either &#x27;illustration&#x27;, &#x27;graph&#x27;, &#x27;table&#x27;, &#x27;chart&#x27;, &#x27;equation&#x27; or &#x27;bar chart&#x27;.&quot;\n\n        # Process the entire screenshot with the minicpm model\n        vision_model_response = process_with_vision_model(image_path, question)\n\n        # Replace the image reference with disk location and vision model response\n        content = content.replace(f&quot;![{image_name}]({image_name})&quot;, f&quot;![{image_name}]({image_name})\\n\\nDisk Location: {image_path}\\n\\nInitial Image ID: {vision_model_response}\\n\\n&quot;)\n\n    with open(md_file_path, &#x27;w&#x27;) as md_file:\n        md_file.write(content)\n\n        # Unload the miniCPM-lama3-v-2_5 model after processing the full image\n        unload_minicpm_llama_model()\n\ndef load_owlv2_model():\n    global owlv2_model, owlv2_processor\n    owlv2_model = Owlv2ForObjectDetection.from_pretrained(&quot;google/owlv2-base-patch16-ensemble&quot;, trust_remote_code=True).to(device)\n    owlv2_processor = Owlv2Processor.from_pretrained(&quot;google/owlv2-base-patch16-ensemble&quot;, trust_remote_code=True)\n    print(&quot;Owlv2 model loaded.&quot;)\n\ndef unload_owlv2_model():\n    global owlv2_model, owlv2_processor\n    if owlv2_model is not None:\n        del owlv2_model\n        del owlv2_processor\n        torch.cuda.empty_cache()\n        print(&quot;Owlv2 model unloaded.&quot;)\n\ndef load_minicpm_llama_model():\n    global minicpm_llama_model, minicpm_llama_tokenizer\n    if &quot;int4&quot; in VISION_MODEL_ID:\n        # Load the 4-bit quantized model and tokenizer\n        minicpm_llama_model = AutoModel.from_pretrained(\n            VISION_MODEL_ID,\n            device_map={&quot;&quot;: device},\n            trust_remote_code=True,\n            torch_dtype=torch.float16  # Use float16 as per the example code for 4-bit models\n        ).eval()\n        minicpm_llama_tokenizer = AutoTokenizer.from_pretrained(\n            VISION_MODEL_ID,\n            trust_remote_code=True\n        )\n        print(&quot;MiniCPM-Llama3 4-bit quantized model loaded on-demand.&quot;)\n    else:\n        # Load the standard model and tokenizer\n        minicpm_llama_model = AutoModel.from_pretrained(\n            VISION_MODEL_ID,\n            device_map={&quot;&quot;: device},  # Use the specified CUDA device\n            trust_remote_code=True,\n            torch_dtype=torch.bfloat16\n        ).eval()\n        minicpm_llama_tokenizer = AutoTokenizer.from_pretrained(\n            VISION_MODEL_ID,\n            trust_remote_code=True\n        )\n        print(&quot;MiniCPM-Llama3 standard model loaded on-demand.&quot;)\n\ndef unload_minicpm_llama_model():\n    global minicpm_llama_model, minicpm_llama_tokenizer\n    if minicpm_llama_model is not None:\n        del minicpm_llama_model\n        del minicpm_llama_tokenizer\n        torch.cuda.empty_cache()\n        print(&quot;MiniCPM-Llama3 model unloaded.&quot;)\n\ndef load_chartgemma_model():\n    global chartgemma_model, chartgemma_processor\n    chartgemma_model = PaliGemmaForConditionalGeneration.from_pretrained(&quot;ahmed-masry/chartgemma&quot;).to(device)\n    chartgemma_processor = AutoProcessor.from_pretrained(&quot;ahmed-masry/chartgemma&quot;)\n    print(&quot;ChartGemma model loaded.&quot;)\n\ndef unload_chartgemma_model():\n    global chartgemma_model, chartgemma_processor\n    if chartgemma_model is not None:\n        del chartgemma_model\n        del chartgemma_processor\n        torch.cuda.empty_cache()\n        print(&quot;ChartGemma model unloaded.&quot;)\n\ndef load_got_ocr_model():\n    global got_ocr_model, got_ocr_tokenizer\n    os.environ[&quot;CUDA_VISIBLE_DEVICES&quot;] = &quot;0&quot;\n    torch.cuda.set_device(0)  # Explicitly set CUDA device\n    \n\n    got_ocr_model = AutoModel.from_pretrained(GOT_OCR_MODEL_PATH, trust_remote_code=True, low_cpu_mem_usage=True, device_map=&#x27;cuda:0&#x27;, use_safetensors=True).eval().cuda()\n    got_ocr_tokenizer = AutoTokenizer.from_pretrained(GOT_OCR_MODEL_PATH, trust_remote_code=True)\n    print(&quot;GOT-OCR model loaded.&quot;)\n\ndef unload_got_ocr_model():\n    global got_ocr_model, got_ocr_tokenizer\n    if got_ocr_model is not None:\n        del got_ocr_model\n        del got_ocr_tokenizer\n        torch.cuda.empty_cache()\n        print(&quot;GOT-OCR model unloaded.&quot;)\n\ndef take_screenshot(monitor_index, text_queries, score_threshold, vision_model_question, full_image_vision_model_question, output_filename=&quot;screenshot.png&quot;):\n    &quot;&quot;&quot;\n    Takes a screenshot of a specific monitor in a multi-monitor setup.\n\n    Args:\n        monitor_index (int): The index of the monitor to capture.\n        text_queries (str): Comma-separated text queries for object detection.\n        score_threshold (float): The score threshold for filtering low-probability predictions.\n        vision_model_question (str): The question to ask the vision model for cropped images.\n        full_image_vision_model_question (str): The question to ask the vision model for the full image.\n        output_filename (str): The filename to save the screenshot as (default is &quot;screenshot.png&quot;).\n    &quot;&quot;&quot;\n    monitor_index = int(monitor_index)\n    score_threshold = float(score_threshold)\n\n    # Get information about all monitors\n    monitors = screeninfo.get_monitors()\n\n    if monitor_index &gt;= len(monitors):\n        raise ValueError(f&quot;Monitor index {monitor_index} is out of range. There are only {len(monitors)} monitors.&quot;)\n\n    # Get the region of the specified monitor\n    monitor = monitors[monitor_index]\n    region = (monitor.x, monitor.y, monitor.width, monitor.height)\n\n    # Take the screenshot\n    output_dir = &quot;extensions/Lucid_Autonomy&quot;\n    os.makedirs(output_dir, exist_ok=True)\n    screenshot_path = os.path.join(output_dir, output_filename)\n    screenshot = pyautogui.screenshot(region=region)\n    screenshot.save(screenshot_path)\n    print(f&quot;Screenshot saved as {screenshot_path}&quot;)\n\n    # Process the image using the Owlv2 model\n    annotated_image_path, human_annotated_image_path, json_output_path = query_image(screenshot_path, text_queries, score_threshold)\n\n    # Load the miniCPM-lama3-v-2_5 model\n    load_minicpm_llama_model()\n\n    # Process the entire screenshot with the minicpm model\n    full_image_response = process_with_vision_model(annotated_image_path, full_image_vision_model_question)\n\n    # Unload the miniCPM-lama3-v-2_5 model after processing the full image\n    unload_minicpm_llama_model()\n\n    # Create the output directory if it doesn&#x27;t exist\n    output_dir = &quot;extensions/Lucid_Autonomy/ImageOutputTest&quot;\n    os.makedirs(output_dir, exist_ok=True)\n\n    # Clear the output directory\n    for filename in os.listdir(output_dir):\n        file_path = os.path.join(output_dir, filename)\n        try:\n            if os.path.isfile(file_path) or os.path.islink(file_path):\n                os.unlink(file_path)\n            elif os.path.isdir(file_path):\n                shutil.rmtree(file_path)\n        except Exception as e:\n            print(f&quot;Failed to delete {file_path}. Reason: {e}&quot;)\n\n    # Crop the detected objects and save them to the output directory\n    crop_images(annotated_image_path, json_output_path, output_dir, full_image_response)\n\n    print(&quot;Processing complete. Check the output directory for the cropped images and results.&quot;)\n\ndef query_image(img_path, text_queries, score_threshold):\n    &quot;&quot;&quot;\n    Processes the image using the Owlv2 model to detect objects based on text queries.\n\n    Args:\n        img_path (str): The path to the input image.\n        text_queries (str): Comma-separated text queries for object detection.\n        score_threshold (float): The score threshold for filtering low-probability predictions.\n    &quot;&quot;&quot;\n    load_owlv2_model()\n\n    img = Image.open(img_path)\n    text_queries = text_queries.split(&quot;,&quot;)\n\n    size = max(img.size)\n    target_sizes = torch.Tensor([[size, size]])\n    inputs = owlv2_processor(text=text_queries, images=img, return_tensors=&quot;pt&quot;).to(device)\n\n    with torch.no_grad():\n        outputs = owlv2_model(**inputs)\n\n    outputs.logits = outputs.logits.cpu()\n    outputs.pred_boxes = outputs.pred_boxes.cpu()\n    results = owlv2_processor.post_process_object_detection(outputs=outputs, target_sizes=target_sizes)\n    boxes, scores, labels = results[0][&quot;boxes&quot;], results[0][&quot;scores&quot;], results[0][&quot;labels&quot;]\n\n    result_labels = []\n    img_pil = img.copy()\n    draw = ImageDraw.Draw(img_pil)\n\n    human_img_pil = img.copy()\n    human_draw = ImageDraw.Draw(human_img_pil)\n\n    for box, score, label in zip(boxes, scores, labels):\n        box = [int(i) for i in box.tolist()]\n        if score &lt; score_threshold:\n            continue\n        result_labels.append([box, text_queries[label.item()]])\n        # Do not draw the text label within the bounding box\n        # draw.text((box[0], box[1]), text_queries[label.item()], fill=&quot;red&quot;)\n\n        # Draw the boxes for the human-annotated image\n        human_draw.rectangle(box, outline=&quot;red&quot;, width=2)\n\n    # Save the annotated image for debugging\n    annotated_image_path = &quot;extensions/Lucid_Autonomy/screenshot.png&quot;\n    img_pil.save(annotated_image_path)\n\n    # Save the human-annotated image for human inspection\n    human_annotated_image_path = &quot;extensions/Lucid_Autonomy/Human_annotated_image.png&quot;\n    human_img_pil.save(human_annotated_image_path)\n\n    # Save the JSON output to a file\n    json_output_path = &quot;extensions/Lucid_Autonomy/output.json&quot;\n    with open(json_output_path, &#x27;w&#x27;) as f:\n        json.dump(result_labels, f)\n\n    unload_owlv2_model()\n\n    return annotated_image_path, human_annotated_image_path, json_output_path\n\ndef crop_images(image_path, json_output_path, output_dir=&quot;extensions/Lucid_Autonomy/ImageOutputTest&quot;, full_image_response=&quot;&quot;):\n    &quot;&quot;&quot;\n    Crops out the detected objects from the input image based on the bounding box coordinates.\n\n    Args:\n        image_path (str): The path to the input image.\n        json_output_path (str): The path to the JSON file containing the bounding box coordinates.\n        output_dir (str): The directory to save the cropped images (default is &quot;extensions/Lucid_Autonomy/ImageOutputTest&quot;).\n        full_image_response (str): The response from the vision model for the full image.\n    &quot;&quot;&quot;\n    with open(json_output_path, &#x27;r&#x27;) as f:\n        data = json.load(f)\n\n    img = Image.open(image_path)\n\n    results = []\n\n    # Load the miniCPM-lama3-v-2_5 model once before processing the images\n    load_minicpm_llama_model()\n\n    for i, item in enumerate(data):\n        box = item[0]\n        label = item[1]\n        cropped_img = img.crop(box)\n        cropped_img_path = f&quot;{output_dir}/{label}_{i}.png&quot;\n        cropped_img.save(cropped_img_path)\n\n        # Process the cropped image with the miniCPM-lama3-v-2_5 model\n        vision_model_response = process_with_vision_model(cropped_img_path, VISION_MODEL_QUESTION)\n\n        # Store the results in a structured format\n        results.append({\n            &quot;image_name&quot;: f&quot;{label}_{i}.png&quot;,\n            &quot;coordinates&quot;: box,\n            &quot;description&quot;: vision_model_response,\n            &quot;children&quot;: []\n        })\n\n    # Unload the miniCPM-lama3-v-2_5 model after processing all images\n    unload_minicpm_llama_model()\n\n    # Determine parent-child relationships\n    for i, result in enumerate(results):\n        for j, other_result in enumerate(results):\n            if i != j:\n                box1 = result[&quot;coordinates&quot;]\n                box2 = other_result[&quot;coordinates&quot;]\n                center_x1 = (box1[0] + box1[2]) // 2\n                center_y1 = (box1[1] + box1[3]) // 2\n                if box2[0] &lt;= center_x1 &lt;= box2[2] and box2[1] &lt;= center_y1 &lt;= box2[3]:\n                    other_result[&quot;children&quot;].append(result[&quot;image_name&quot;])\n\n    # Save the results to a JSON file\n    results_json_path = f&quot;{output_dir}/results.json&quot;\n    with open(results_json_path, &#x27;w&#x27;) as f:\n        json.dump(results, f, indent=4)\n\n    # Add the full image response to the results\n    if full_image_response:\n        results.append({\n            &quot;image_name&quot;: &quot;full_image.png&quot;,\n            &quot;coordinates&quot;: [],\n            &quot;description&quot;: full_image_response,\n            &quot;children&quot;: []\n        })\n\n        # Save the updated results to the JSON file\n        with open(results_json_path, &#x27;w&#x27;) as f:\n            json.dump(results, f, indent=4)\n\ndef process_with_vision_model(image_path, question):\n    &quot;&quot;&quot;\n    Processes the image with the miniCPM-lama3-v-2_5 model and returns the response.\n\n    Args:\n        image_path (str): The path to the input image.\n        question (str): The question to ask the vision model.\n\n    Returns:\n        str: The response from the vision model.\n    &quot;&quot;&quot;\n    image = Image.open(image_path).convert(&quot;RGB&quot;)\n    messages = [\n        {&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: f&quot;{question}&quot;}\n    ]\n    # Define the generation arguments\n    generation_args = {\n        &quot;max_new_tokens&quot;: 1024,\n        &quot;repetition_penalty&quot;: 1.05,\n        &quot;num_beams&quot;: 3,\n        &quot;top_p&quot;: 0.9,\n        &quot;top_k&quot;: 1,\n        &quot;temperature&quot;: 0.1,\n        &quot;sampling&quot;: True,\n    }\n    if &quot;int4&quot; in VISION_MODEL_ID:\n        # Disable streaming for the 4-bit model\n        generation_args[&quot;stream&quot;] = False\n        # Use the model.chat method with streaming enabled\n        vision_model_response = &quot;&quot;\n        for new_text in minicpm_llama_model.chat(\n                image=image,\n                msgs=messages,\n                tokenizer=minicpm_llama_tokenizer,\n                **generation_args\n        ):\n            vision_model_response += new_text\n            print(new_text, flush=True, end=&#x27;&#x27;)\n\n    else:\n        minicpm_llama_model.to(device)\n        vision_model_response = minicpm_llama_model.chat(\n            image=image,\n            msgs=messages,\n            tokenizer=minicpm_llama_tokenizer,\n            **generation_args\n        )\n    return vision_model_response\n\ndef process_with_chartgemma_model(image_path, question):\n    &quot;&quot;&quot;\n    Processes the image with the ChartGemma model and returns the response.\n\n    Args:\n        image_path (str): The path to the input image.\n        question (str): The question to ask the vision model.\n\n    Returns:\n        str: The response from the vision model.\n    &quot;&quot;&quot;\n    image = Image.open(image_path).convert(&quot;RGB&quot;)\n    inputs = chartgemma_processor(text=question, images=image, return_tensors=&quot;pt&quot;)\n    inputs = {k: v.to(device) for k, v in inputs.items()}\n\n    prompt_length = inputs[&#x27;input_ids&#x27;].shape[1]\n\n    # Generate\n    generate_ids = chartgemma_model.generate(**inputs, max_new_tokens=512)\n    output_text = chartgemma_processor.batch_decode(generate_ids[:, prompt_length:], skip_special_tokens=True, clean_up_tokenization_spaces=False)[0]\n\n    return output_text\n\ndef convert_pdf_to_png(pdf_path, output_folder):\n    &quot;&quot;&quot;\n    Converts each page of the input PDF to a PNG file and saves them in the specified output folder.\n\n    Args:\n        pdf_path (str): The path to the input PDF file.\n        output_folder (str): The path to the output folder where the PNG files will be saved.\n    &quot;&quot;&quot;\n    os.makedirs(output_folder, exist_ok=True)\n    images = pdf2image.convert_from_path(pdf_path)\n    for i, image in enumerate(images):\n        image.save(os.path.join(output_folder, f&quot;page_{i+1}.png&quot;), &quot;PNG&quot;)\n\n# Define the base directories\nBASE_UPLOAD_FOLDER = &quot;extensions/Lucid_Autonomy/MarkerOutput&quot;\nBASE_RESULTS_FOLDER = &quot;extensions/Lucid_Autonomy/MarkerOutput&quot;\n\ndef run_got_ocr(image_path, got_mode, fine_grained_mode=&quot;&quot;, ocr_color=&quot;&quot;, ocr_box=&quot;&quot;):\n    # Extract the PDF name from the image path\n    pdf_name = os.path.basename(os.path.dirname(image_path))\n\n    # Define the upload and results folders based on the PDF name\n    UPLOAD_FOLDER = os.path.join(BASE_UPLOAD_FOLDER, pdf_name)\n    RESULTS_FOLDER = os.path.join(BASE_RESULTS_FOLDER, pdf_name)\n\n    # Ensure the directories exist\n    os.makedirs(UPLOAD_FOLDER, exist_ok=True)\n    os.makedirs(RESULTS_FOLDER, exist_ok=True)\n\n    unique_id = str(uuid.uuid4())\n    temp_image_path = os.path.join(UPLOAD_FOLDER, f&quot;{unique_id}.png&quot;)\n    result_path = os.path.join(RESULTS_FOLDER, f&quot;{unique_id}.html&quot;)\n\n    shutil.copy(image_path, temp_image_path)\n\n    try:\n        if got_mode == &quot;plain texts OCR&quot;:\n            res = got_ocr_model.chat(got_ocr_tokenizer, temp_image_path, ocr_type=&#x27;ocr&#x27;)\n            return res, None\n        elif got_mode == &quot;format texts OCR&quot;:\n            res = got_ocr_model.chat(got_ocr_tokenizer, temp_image_path, ocr_type=&#x27;format&#x27;, render=True, save_render_file=result_path)\n        elif got_mode == &quot;plain multi-crop OCR&quot;:\n            res = got_ocr_model.chat_crop(got_ocr_tokenizer, temp_image_path, ocr_type=&#x27;ocr&#x27;)\n            return res, None\n        elif got_mode == &quot;format multi-crop OCR&quot;:\n            res = got_ocr_model.chat_crop(got_ocr_tokenizer, temp_image_path, ocr_type=&#x27;format&#x27;, render=True, save_render_file=result_path)\n        elif got_mode == &quot;plain fine-grained OCR&quot;:\n            res = got_ocr_model.chat(got_ocr_tokenizer, temp_image_path, ocr_type=&#x27;ocr&#x27;, ocr_box=ocr_box, ocr_color=ocr_color)\n            return res, None\n        elif got_mode == &quot;format fine-grained OCR&quot;:\n            res = got_ocr_model.chat(got_ocr_tokenizer, temp_image_path, ocr_type=&#x27;format&#x27;, ocr_box=ocr_box, ocr_color=ocr_color, render=True, save_render_file=result_path)\n\n        res_markdown = res\n\n        if &quot;format&quot; in got_mode and os.path.exists(result_path):\n            with open(result_path, &#x27;r&#x27;) as f:\n                html_content = f.read()\n            encoded_html = base64.b64encode(html_content.encode(&#x27;utf-8&#x27;)).decode(&#x27;utf-8&#x27;)\n            iframe_src = f&quot;data:text/html;base64,{encoded_html}&quot;\n            iframe = f&#x27;&lt;iframe src=&quot;{iframe_src}&quot; width=&quot;100%&quot; height=&quot;600px&quot;&gt;&lt;/iframe&gt;&#x27;\n            download_link = f&#x27;&lt;a href=&quot;data:text/html;base64,{encoded_html}&quot; download=&quot;result_{unique_id}.html&quot;&gt;Download Full Result&lt;/a&gt;&#x27;\n            return res_markdown, f&quot;{download_link}&lt;br&gt;{iframe}&quot;\n        else:\n            return res_markdown, None\n    except Exception as e:\n        return f&quot;Error: {str(e)}&quot;, None\n    finally:\n        if os.path.exists(temp_image_path):\n            os.remove(temp_image_path)\n\n\ndef compare_and_merge_texts(file1_path, file2_path, group_size, output_path):\n    # Read and clean both files\n    with open(file1_path, &#x27;r&#x27;) as f1, open(file2_path, &#x27;r&#x27;) as f2:\n        text1 = clean_text_doc2(f1.read())\n        text2 = clean_text_doc2(f2.read())\n\n    # Get word groups (case-insensitive for comparison)\n    groups1 = [group.lower() for group in get_word_groups(text1, group_size)]\n    groups2 = [group.lower() for group in get_word_groups(text2, group_size)]\n\n    # Find common groups\n    common_groups = set(groups1) &amp; set(groups2)\n\n    # Remove common groups from text1 (case-sensitive removal)\n    for group in common_groups:\n        text1 = re.sub(re.escape(group), &#x27;&#x27;, text1, flags=re.IGNORECASE)\n\n    # Merge unique parts of text1 into text2\n    merged_text = text2 + &#x27; &#x27; + text1.strip()\n\n    # Write the result to the output file\n    with open(output_path, &#x27;w&#x27;) as f_out:\n        f_out.write(merged_text)\n\n    print(f&quot;Merged text has been written to {output_path}&quot;)\n\ndef clean_text_doc2(text):\n    # Preserve all special characters, punctuation, and capitalization...just dont ahhah\n    return text\n\ndef get_word_groups(text, group_size):\n    words = re.findall(r&#x27;\\S+&#x27;, text)\n    return [&#x27; &#x27;.join(words[i:i+group_size]) for i in range(len(words) - group_size + 1)]\n\n# Global variables for Gradio inputs\nglobal_vars = {\n    &quot;global_monitor_index&quot;: &quot;global_monitor_index&quot;,\n    &quot;global_text_queries&quot;: TEXT_QUERIES,\n    &quot;global_score_threshold&quot;: SCORE_THRESHOLD,\n    &quot;global_vision_model_question&quot;: VISION_MODEL_QUESTION,\n    &quot;global_full_image_vision_model_question&quot;: FULL_IMAGE_VISION_MODEL_QUESTION\n}\n\ndef ui():\n    &quot;&quot;&quot;\n    Creates custom gradio elements when the UI is launched.\n    &quot;&quot;&quot;\n    with gr.Blocks() as demo:\n        with gr.Row():\n            with gr.Column():\n                monitor_index = gr.Textbox(label=&quot;Monitor Index&quot;, value=str(MONITOR_INDEX))\n                text_queries = gr.Textbox(label=&quot;Text Queries&quot;, value=TEXT_QUERIES)\n                score_threshold = gr.Textbox(label=&quot;Score Threshold&quot;, value=str(SCORE_THRESHOLD))\n                vision_model_question = gr.Textbox(label=&quot;Vision Model Question&quot;, value=VISION_MODEL_QUESTION)\n                full_image_vision_model_question = gr.Textbox(label=&quot;Full Image Vision Model Question&quot;, value=FULL_IMAGE_VISION_MODEL_QUESTION)\n                take_screenshot_button = gr.Button(value=&quot;Take Screenshot&quot;)\n                process_screenshot_button = gr.Button(value=&quot;Process Screenshot With GOT-OCR&quot;)\n\n                # File upload component\n                file_upload = gr.File(label=&quot;Upload PDF File&quot;)\n\n                # Radio checkbox for GOT-OCR\n                use_got_ocr = gr.Checkbox(label=&quot;Use GOT-OCR&quot;, value=False)\n\n                # Text box for group_size\n                group_size = gr.Textbox(label=&quot;Group Size&quot;, value=&quot;5&quot;)\n\n                # Checkbox for using results.json\n                use_results_json = gr.Checkbox(label=&quot;Use results.json&quot;, value=True)\n\n                # Button to clear results.json\n                clear_results_button = gr.Button(value=&quot;Clear results.json&quot;)\n\n                # New button to unload all models\n                unload_models_button = gr.Button(value=&quot;Unload All Models&quot;)\n\n        # Update global variables when the user changes the input fields\n        monitor_index.change(lambda x: global_vars.update({&quot;global_monitor_index&quot;: int(x)}), inputs=monitor_index, outputs=None)\n        text_queries.change(lambda x: global_vars.update({&quot;global_text_queries&quot;: x}), inputs=text_queries, outputs=None)\n        score_threshold.change(lambda x: global_vars.update({&quot;global_score_threshold&quot;: float(x)}), inputs=score_threshold, outputs=None)\n        vision_model_question.change(lambda x: global_vars.update({&quot;global_vision_model_question&quot;: x}), inputs=vision_model_question, outputs=None)\n        full_image_vision_model_question.change(lambda x: global_vars.update({&quot;global_full_image_vision_model_question&quot;: x}), inputs=full_image_vision_model_question, outputs=None)\n\n        take_screenshot_button.click(\n            fn=take_screenshot,\n            inputs=[monitor_index, text_queries, score_threshold, vision_model_question, full_image_vision_model_question],\n            outputs=None\n        )\n\n        process_screenshot_button.click(\n            fn=process_screenshot_with_got_ocr,\n            inputs=[monitor_index],\n            outputs=None\n        )\n\n        # Handle file upload event\n        file_upload.upload(\n            fn=handle_file_upload_and_copy,\n            inputs=[file_upload, use_got_ocr, group_size],\n            outputs=None\n        )\n\n        # Add the checkbox state to the global variables\n        use_results_json.change(lambda x: global_vars.update({&quot;use_results_json&quot;: x}), inputs=use_results_json, outputs=None)\n\n        # Handle clear results.json button click\n        clear_results_button.click(\n            fn=clear_results_json,\n            inputs=None,\n            outputs=None\n        )\n\n        # Click event handler for the new button\n        unload_models_button.click(\n            fn=unload_all_models,\n            inputs=None,\n            outputs=None\n        )\n\n    return demo\n\ndef handle_file_upload_and_copy(file, use_got_ocr, group_size):\n    &quot;&quot;&quot;\n    Handles the file upload event and creates a copy of the PDF.\n    &quot;&quot;&quot;\n    if file is not None:\n        file_path = file.name\n        output_folder = &quot;extensions/Lucid_Autonomy/MarkerOutput&quot;\n        os.makedirs(output_folder, exist_ok=True)\n\n        # Create a subfolder with the same name as the PDF\n        pdf_name = os.path.splitext(os.path.basename(file_path))[0]\n        pdf_subfolder = os.path.join(output_folder, pdf_name)\n        os.makedirs(pdf_subfolder, exist_ok=True)\n\n        # Copy the uploaded PDF to the subfolder\n        pdf_copy_path = os.path.join(pdf_subfolder, os.path.basename(file_path))\n        shutil.copy2(file_path, pdf_copy_path)\n        print(f&quot;Created a copy of the PDF: {pdf_copy_path}&quot;)\n\n        # Continue with the rest of the file processing\n        handle_file_upload(file, use_got_ocr, group_size)\n\n# Define the function to unload all models\ndef unload_all_models():\n    unload_owlv2_model()\n    unload_minicpm_llama_model()\n    unload_chartgemma_model()\n    unload_got_ocr_model()\n    torch.cuda.empty_cache()\n    print(&quot;All models unloaded.&quot;)\n\n\n\n# Define the function to process the screenshot with GOT-OCR\ndef process_screenshot_with_got_ocr(monitor_index):\n    monitor_index = int(monitor_index)\n\n    # Get information about all monitors\n    monitors = screeninfo.get_monitors()\n\n    if monitor_index &gt;= len(monitors):\n        raise ValueError(f&quot;Monitor index {monitor_index} is out of range. There are only {len(monitors)} monitors.&quot;)\n\n    # Get the region of the specified monitor\n    monitor = monitors[monitor_index]\n    region = (monitor.x, monitor.y, monitor.width, monitor.height)\n\n    # Take the screenshot\n    output_dir = &quot;extensions/Lucid_Autonomy&quot;\n    os.makedirs(output_dir, exist_ok=True)\n    output_filename = &quot;screenshot.png&quot;\n    screenshot_path = os.path.join(output_dir, output_filename)\n    screenshot = pyautogui.screenshot(region=region)\n    screenshot.save(screenshot_path)\n    print(f&quot;Screenshot saved as {screenshot_path}&quot;)\n\n    # Load the GOT-OCR model\n    load_got_ocr_model()\n    print(&quot;GOT-OCR model loaded.&quot;)\n\n    # Process the screenshot with GOT-OCR\n    got_ocr_result, _ = run_got_ocr(screenshot_path, got_mode=&quot;plain texts OCR&quot;)\n    print(f&quot;GOT-OCR result: {got_ocr_result}&quot;)\n\n    # Save the GOT-OCR result to results.json\n    results_json_path = &quot;extensions/Lucid_Autonomy/ImageOutputTest/results.json&quot;\n    with open(results_json_path, &#x27;w&#x27;) as f:\n        json.dump([{&quot;image_name&quot;: &quot;screenshot.png&quot;, &quot;description&quot;: got_ocr_result}], f, indent=4)\n\n    # Unload the GOT-OCR model\n    unload_got_ocr_model()\n    print(&quot;GOT-OCR model unloaded.&quot;)\n\n    print(&quot;Screenshot processed with GOT-OCR and results saved to results.json&quot;)\n\n\n\n\n\n\n# Function to clear the results.json file\ndef clear_results_json():\n    &quot;&quot;&quot;\n    Clears the contents of the results.json file and replaces it with an empty list.\n    &quot;&quot;&quot;\n    results_json_path = &quot;extensions/Lucid_Autonomy/ImageOutputTest/results.json&quot;\n    with open(results_json_path, &#x27;w&#x27;) as f:\n        json.dump([], f)\n    print(f&quot;Cleared the contents of {results_json_path}&quot;)\n\n\ndef handle_file_upload(file, use_got_ocr, group_size):\n    &quot;&quot;&quot;\n    Handles the file upload event.\n    &quot;&quot;&quot;\n    global selected_image_path\n    global selected_markdown_path\n    if file is not None:\n        file_path = file.name\n        output_folder = &quot;extensions/Lucid_Autonomy/MarkerOutput&quot;\n        os.makedirs(output_folder, exist_ok=True)\n\n        # Convert PDF to PNG\n        png_output_folder = os.path.join(output_folder, os.path.splitext(os.path.basename(file_path))[0])\n        os.makedirs(png_output_folder, exist_ok=True)\n        convert_pdf_to_png(file_path, png_output_folder)\n\n        if use_got_ocr:\n            \n\n            # Process the PDF with Marker\n\n            \n            process_marker_file(file_path, output_folder)\n            print(f&quot;Processed file: {file_path}&quot;)\n\n            # Generate a list of images\n            image_list = generate_image_list(output_folder)\n\n            # Locate the markdown file within the subfolder\n            pdf_name = os.path.splitext(os.path.basename(file_path))[0]\n            md_file_path = os.path.join(output_folder, pdf_name, f&quot;{pdf_name}.md&quot;)\n\n            # Match image references in the markdown file\n            image_references = match_image_references(md_file_path, image_list)\n\n            # Add disk location information and vision model response to the markdown file\n            add_disk_location_info(md_file_path, image_references)\n\n            print(f&quot;Updated markdown file with disk location information and vision model response: {md_file_path}&quot;)\n            \n            # Load GOT-OCR model\n            load_got_ocr_model()\n\n            # Process each PNG file with GOT-OCR, only selecting files with the format &quot;page_#.png&quot;\n            png_files = [os.path.join(png_output_folder, f) for f in os.listdir(png_output_folder) if re.match(r&#x27;^page_\\d+\\.png$&#x27;, f)]\n\n            # Sort the PNG files based on the page number\n            png_files.sort(key=lambda x: int(re.search(r&#x27;page_(\\d+)\\.png&#x27;, os.path.basename(x)).group(1)))\n\n\n            got_ocr_results = []\n            for png_file in png_files:\n                got_ocr_result, _ = run_got_ocr(png_file, got_mode=&quot;format texts OCR&quot;)\n                got_ocr_results.append(got_ocr_result)\n\n            # Unload GOT-OCR model\n            unload_got_ocr_model()\n\n            # Stitch GOT-OCR outputs into a single markdown file\n            got_ocr_output_path = os.path.join(png_output_folder, &quot;got_ocr_output.md&quot;)\n            with open(got_ocr_output_path, &#x27;w&#x27;) as f_out:\n                for result in got_ocr_results:\n                    f_out.write(result + &quot;\\n\\n&quot;)\n\n            # Merge GOT-OCR output with Marker output\n            compare_and_merge_texts(got_ocr_output_path, md_file_path, group_size=int(group_size), output_path=md_file_path)\n\n            # Set the global variable for the selected image path\n            selected_image_path = md_file_path\n            selected_markdown_path = md_file_path\n        else:\n            # Process the PDF with Marker without GOT-OCR\n            process_marker_file(file_path, output_folder)\n            print(f&quot;Processed file: {file_path}&quot;)\n\n            # Generate a list of images\n            image_list = generate_image_list(output_folder)\n\n            # Locate the markdown file within the subfolder\n            pdf_name = os.path.splitext(os.path.basename(file_path))[0]\n            md_file_path = os.path.join(output_folder, pdf_name, f&quot;{pdf_name}.md&quot;)\n\n            # Match image references in the markdown file\n            image_references = match_image_references(md_file_path, image_list)\n\n            # Add disk location information and vision model response to the markdown file\n            add_disk_location_info(md_file_path, image_references)\n\n            print(f&quot;Updated markdown file with disk location information and vision model response: {md_file_path}&quot;)\n\n            # Set the global variable for the selected image path\n            selected_image_path = md_file_path\n            selected_markdown_path = md_file_path\n\n\n\n# Modify the input_modifier function\ndef input_modifier(user_input, state):\n    &quot;&quot;&quot;\n    Modifies the user input before it is processed by the LLM.\n    &quot;&quot;&quot;\n    global selected_image_path\n    global selected_markdown_path\n\n    # Check if a markdown file has been selected and stored in the global variable\n    if selected_markdown_path:\n        # Read the contents of the markdown file\n        with open(selected_markdown_path, &#x27;r&#x27;) as md_file:\n            markdown_content = md_file.read()\n\n        # Construct the message with the markdown content\n        combined_input = f&quot;{user_input}\\n\\n{markdown_content}&quot;\n\n        # Reset the selected markdown path to None after processing\n        selected_markdown_path = None\n        return combined_input\n\n    # If no markdown file is selected, return the user input as is\n    return user_input\n\naria_model = None\naria_processor = None\n\ndef load_aria_model():\n    global aria_model, aria_processor\n    if aria_model is None:\n        print(&quot;Loading ARIA model...&quot;)\n        aria_model = AutoModelForCausalLM.from_pretrained(\n            &quot;/home/myself/Desktop/Aria/&quot;,\n            device_map=&quot;auto&quot;,\n            torch_dtype=torch.bfloat16,\n            trust_remote_code=True\n        )\n        aria_processor = AutoProcessor.from_pretrained(\n            &quot;/home/myself/Desktop/Aria/&quot;,\n            trust_remote_code=True\n        )\n        print(&quot;ARIA model loaded successfully.&quot;)\n    else:\n        print(&quot;ARIA model already loaded.&quot;)\n\ndef unload_aria_model():\n    global aria_model, aria_processor\n    if aria_model is not None:\n        print(&quot;Unloading ARIA model...&quot;)\n        # Move model to CPU before deletion\n        aria_model.cpu()\n        # Delete the model and processor\n        del aria_model\n        del aria_processor\n        # Set to None to indicate they&#x27;re unloaded\n        aria_model = None\n        aria_processor = None\n        # Clear CUDA cache\n        if torch.cuda.is_available():\n            torch.cuda.empty_cache()\n        # Run garbage collection\n        gc.collect()\n        print(&quot;ARIA model unloaded successfully.&quot;)\n    else:\n        print(&quot;ARIA model not loaded, nothing to unload.&quot;)\n    \n    # Print current GPU memory usage\n    if torch.cuda.is_available():\n        print(f&quot;Current GPU memory allocated: {torch.cuda.memory_allocated() / 1e9:.2f} GB&quot;)\n        print(f&quot;Current GPU memory reserved: {torch.cuda.memory_reserved() / 1e9:.2f} GB&quot;)\n\ndef process_with_aria_model(image_path, question):\n    global aria_model, aria_processor\n    \n    if aria_model is None:\n        load_aria_model()\n    \n    print(&quot;Processing image with ARIA model...&quot;)\n    image = Image.open(image_path).convert(&quot;RGB&quot;)\n    messages = [\n        {&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: [\n            {&quot;text&quot;: None, &quot;type&quot;: &quot;image&quot;},\n            {&quot;text&quot;: question, &quot;type&quot;: &quot;text&quot;},\n        ]}\n    ]\n    \n    text = aria_processor.apply_chat_template(messages, add_generation_prompt=True)\n    inputs = aria_processor(text=text, images=image, return_tensors=&quot;pt&quot;)\n    inputs[&quot;pixel_values&quot;] = inputs[&quot;pixel_values&quot;].to(aria_model.dtype)\n    inputs = {k: v.to(aria_model.device) for k, v in inputs.items()}\n\n    with torch.inference_mode(), torch.cuda.amp.autocast(dtype=torch.bfloat16):\n        output = aria_model.generate(\n            **inputs,\n            max_new_tokens=1024,\n            stop_strings=[&quot;&lt;|im_end|&gt;&quot;],\n            tokenizer=aria_processor.tokenizer,\n            do_sample=True,\n            temperature=0.9,\n        )\n        output_ids = output[0][inputs[&quot;input_ids&quot;].shape[1]:]\n        result = aria_processor.decode(output_ids, skip_special_tokens=True)\n\n    print(&quot;Image processing complete.&quot;)\n    return result\n\n# Modify the output_modifier function to handle the new trigger phrase\ndef output_modifier(output, state):\n    &quot;&quot;&quot;\n    Modifies the LLM output before it is presented in the UI.\n    &quot;&quot;&quot;\n    global oob_tasks\n\n    # Search for the &quot;Autonomy_Tasks:&quot; trigger phrase in the LLM&#x27;s output\n    if &quot;Autonomy_Tasks:&quot; in output:\n        # Clean the chat history\n        state[&quot;history&quot;] = history_modifier(state[&quot;history&quot;])\n        # Extract tasks and execute them\n        tasks_section = output.split(&quot;Autonomy_Tasks:&quot;)[-1].strip()\n        if tasks_section:\n            # Write OOB tasks to a JSON file\n            with open(oob_tasks_file, &#x27;w&#x27;) as f:\n                json.dump(tasks_section.split(&quot;\\n&quot;), f)\n\n            # Trigger the execution of OOB tasks after a delay\n            threading.Thread(target=execute_oob_tasks_with_delay).start()\n\n    # Search for the &quot;Image_File_Location:&quot; trigger phrase in the LLM&#x27;s output\n    file_location_matches = re.findall(r&quot;Image_File_Location: (.+)$&quot;, output, re.MULTILINE)\n    if file_location_matches:\n        # Extract the first match (assuming only one file location per output)\n        file_path = file_location_matches[0]\n        # Extract the questions for the vision model\n        questions_section, _ = output.split(f&quot;Image_File_Location: {file_path}&quot;, 1)\n        # Remove all newlines from the questions section and replace them with spaces\n        questions = &quot; &quot;.join(questions_section.strip().splitlines())\n\n        # Initialize an empty response string\n        vision_model_response = &quot;&quot;\n\n        load_minicpm_llama_model()\n        # Process the image with the MiniCPM model\n        vision_model_response = process_with_vision_model(file_path, questions)\n        unload_minicpm_llama_model()\n\n        # Format the image path for inline display\n        relative_path = file_path.split(&quot;extensions/&quot;)[-1]\n        formatted_image_path = f&quot;&lt;img src=\\&quot;/file/extensions/{relative_path}\\&quot;&gt;&quot;\n\n        # Append the vision model&#x27;s responses and the formatted image path to the output\n        output_with_responses = f&quot;{output}\\n\\nVision Model Responses:\\n{vision_model_response}\\n\\n{formatted_image_path}&quot;\n        return output_with_responses\n\n    # Search for the &quot;Data_File_Location:&quot; trigger phrase in the LLM&#x27;s output\n    data_file_location_matches = re.findall(r&quot;Data_File_Location: (.+)$&quot;, output, re.MULTILINE)\n    if data_file_location_matches:\n        # Extract the first match (assuming only one file location per output)\n        file_path = data_file_location_matches[0]\n        # Extract the questions for the vision model\n        questions_section, _ = output.split(f&quot;Data_File_Location: {file_path}&quot;, 1)\n        # Remove all newlines from the questions section and replace them with spaces\n        questions = &quot; &quot;.join(questions_section.strip().splitlines())\n\n        # Initialize an empty response string\n        vision_model_response = &quot;&quot;\n\n        load_chartgemma_model()\n        # Process the image with the ChartGemma model\n        vision_model_response = process_with_chartgemma_model(file_path, questions)\n        unload_chartgemma_model()\n\n        # Format the image path for inline display\n        relative_path = file_path.split(&quot;extensions/&quot;)[-1]\n        formatted_image_path = f&quot;&lt;img src=\\&quot;/file/extensions/{relative_path}\\&quot;&gt;&quot;\n\n        # Append the vision model&#x27;s responses and the formatted image path to the output\n        output_with_responses = f&quot;{output}\\n\\nVision Model Responses:\\n{vision_model_response}\\n\\n{formatted_image_path}&quot;\n        return output_with_responses\n\n    # Search for the &quot;ARIA_File_Location:&quot; trigger phrase in the LLM&#x27;s output\n    aria_file_location_matches = re.findall(r&quot;ARIA_File_Location: (.+)$&quot;, output, re.MULTILINE)\n    if aria_file_location_matches:\n        # Extract the first match (assuming only one file location per output)\n        file_path = aria_file_location_matches[0]\n        # Extract the questions for the vision model\n        questions_section, _ = output.split(f&quot;ARIA_File_Location: {file_path}&quot;, 1)\n        # Remove all newlines from the questions section and replace them with spaces\n        questions = &quot; &quot;.join(questions_section.strip().splitlines())\n\n        # Initialize an empty response string\n        vision_model_response = &quot;&quot;\n\n        load_aria_model()\n        # Process the image with the ARIA model\n        vision_model_response = process_with_aria_model(file_path, questions)\n        unload_aria_model()\n\n        # Format the image path for inline display\n        relative_path = file_path.split(&quot;extensions/&quot;)[-1]\n        formatted_image_path = f&quot;&lt;img src=\\&quot;/file/extensions/{relative_path}\\&quot;&gt;&quot;\n\n        # Append the vision model&#x27;s responses and the formatted image path to the output\n        output_with_responses = f&quot;{output}\\n\\nVision Model Responses:\\n{vision_model_response}\\n\\n{formatted_image_path}&quot;\n        return output_with_responses\n\n    # If no file location is found, return the output as is\n    return output\n\n\noob_tasks = []\n\ndef execute_oob_tasks(tasks_section):\n    &quot;&quot;&quot;\n    Executes the OOB tasks listed in the tasks_section.\n    &quot;&quot;&quot;\n    global oob_tasks\n    tasks = tasks_section\n    for task in tasks:\n        task = task.strip()\n        if task.startswith(&quot;OOB_MouseMover =&quot;):\n            image_name = task.split(&quot;=&quot;)[1].strip()\n            move_mouse_to_image(image_name)\n        elif task.startswith(&quot;OOB_MouseClick =&quot;):\n            value = task.split(&quot;=&quot;)[1].strip()\n            if &quot;,&quot; in value:  # Check if the value contains coordinates\n                coordinates = value\n                left_click_coordinates_raw(coordinates)\n            else:  # Otherwise, treat it as an image name\n                image_name = value\n                left_click_image(image_name)\n        elif task.startswith(&quot;OOB_TextInput =&quot;):\n            text = task.split(&quot;=&quot;)[1].strip()\n            text_input(text)\n        elif task.startswith(&quot;OOB_SpecialKey =&quot;):\n            key = task.split(&quot;=&quot;)[1].strip()\n            special_key(key)\n        elif task.startswith(&quot;OOB_FunctionKey =&quot;):\n            key = task.split(&quot;=&quot;)[1].strip()\n            function_key(key)\n        elif task.startswith(&quot;OOB_KeyCombo =&quot;):\n            combo = task.split(&quot;=&quot;)[1].strip()\n            key_combo(combo)\n        elif task.startswith(&quot;OOB_Delay =&quot;):\n            delay = int(task.split(&quot;=&quot;)[1].strip())\n            delay_task(delay)\n        elif task.startswith(&quot;OOB_MouseMove =&quot;):\n            coordinates = task.split(&quot;=&quot;)[1].strip()\n            move_mouse_to_coordinates_raw(coordinates)\n        elif task == &quot;OOB_TakeScreenshot&quot;:\n            take_screenshot_task()\n        elif task == &quot;OOB_PageUp&quot;:\n            pyautogui.press(&quot;pageup&quot;)\n        elif task == &quot;OOB_PageDown&quot;:\n            pyautogui.press(&quot;pagedown&quot;)\n        else:\n            print(f&quot;Unknown OOB task: {task}&quot;)\n\n        time.sleep(0.2)\n\ndef execute_oob_tasks_with_delay():\n    &quot;&quot;&quot;\n    Executes the saved OOB tasks after a delay.\n    &quot;&quot;&quot;\n    time.sleep(0.1)  # Short delay to ensure the LLM&#x27;s response has completed\n    with open(oob_tasks_file, &#x27;r&#x27;) as f:\n        oob_tasks = json.load(f)\n    execute_oob_tasks(oob_tasks)\n\ndef delay_task(delay):\n    &quot;&quot;&quot;\n    Adds a delay in milliseconds.\n    &quot;&quot;&quot;\n    time.sleep(delay / 1000.0)\n\ndef move_mouse_to_coordinates_raw(coordinates):\n    &quot;&quot;&quot;\n    Moves the mouse to the specified raw coordinates on the specified monitor.\n\n    Args:\n        coordinates (str): A string containing the monitor index and coordinates in the format &quot;monitor_index,x,y&quot;.\n    &quot;&quot;&quot;\n    monitor_indexx, x, y = map(int, coordinates.split(&quot;,&quot;))\n    monitors = screeninfo.get_monitors()\n\n    if monitor_indexx &gt;= len(monitors):\n        raise ValueError(f&quot;Monitor index {monitor_indexx} is out of range. There are only {len(monitors)} monitors.&quot;)\n\n    monitor = monitors[monitor_indexx]\n    monitor_x, monitor_y = monitor.x, monitor.y\n    absolute_x = monitor_x + x\n    absolute_y = monitor_y + y\n    pyautogui.moveTo(absolute_x, absolute_y)\n    print(f&quot;Mouse moved to coordinates: ({absolute_x}, {absolute_y}) on monitor {monitor_indexx}&quot;)\n\ndef left_click_coordinates_raw(coordinates):\n    &quot;&quot;&quot;\n    Moves the mouse to the specified raw coordinates on the specified monitor and performs a left click.\n\n    Args:\n        coordinates (str): A string containing the monitor index and coordinates in the format &quot;monitor_index,x,y&quot;.\n    &quot;&quot;&quot;\n    monitor_indexx, x, y = map(int, coordinates.split(&quot;,&quot;))\n    monitors = screeninfo.get_monitors()\n\n    if monitor_indexx &gt;= len(monitors):\n        raise ValueError(f&quot;Monitor index {monitor_indexx} is out of range. There are only {len(monitors)} monitors.&quot;)\n\n    monitor = monitors[monitor_indexx]\n    monitor_x, monitor_y = monitor.x, monitor.y\n    absolute_x = monitor_x + x\n    absolute_y = monitor_y + y\n    pyautogui.moveTo(absolute_x, absolute_y)\n    pyautogui.click()\n    print(f&quot;Mouse clicked at coordinates: ({absolute_x}, {absolute_y}) on monitor {monitor_indexx}&quot;)\n\ndef take_screenshot_task():\n    &quot;&quot;&quot;\n    Takes a screenshot using the current values from the Gradio interface.\n    &quot;&quot;&quot;\n    take_screenshot(global_vars[&quot;global_monitor_index&quot;], global_vars[&quot;global_text_queries&quot;], global_vars[&quot;global_score_threshold&quot;], global_vars[&quot;global_vision_model_question&quot;], global_vars[&quot;global_full_image_vision_model_question&quot;])\n\ndef move_mouse_to_image(image_name):\n    &quot;&quot;&quot;\n    Moves the mouse to the center of the box that defines the image.\n    &quot;&quot;&quot;\n    results_json_path = &quot;extensions/Lucid_Autonomy/ImageOutputTest/results.json&quot;\n    with open(results_json_path, &#x27;r&#x27;) as f:\n        results = json.load(f)\n\n    # Access the global monitor index from global_vars\n    monitor_index = global_vars.get(&quot;global_monitor_index&quot;, MONITOR_INDEX)\n\n    for result in results:\n        if result[&quot;image_name&quot;] == image_name:\n            coordinates = result[&quot;coordinates&quot;]\n            monitor = get_monitor_info(monitor_index)\n            move_mouse_to_coordinates(monitor, coordinates)\n            break\n    else:\n        print(f&quot;Image name &#x27;{image_name}&#x27; not found in the results.&quot;)\n\ndef left_click_image(image_name):\n    &quot;&quot;&quot;\n    Moves the mouse to the center of the box that defines the image and performs a left click.\n    &quot;&quot;&quot;\n    results_json_path = &quot;extensions/Lucid_Autonomy/ImageOutputTest/results.json&quot;\n    with open(results_json_path, &#x27;r&#x27;) as f:\n        results = json.load(f)\n\n    # Access the global monitor index from global_vars\n    monitor_index = global_vars.get(&quot;global_monitor_index&quot;, MONITOR_INDEX)\n\n    for result in results:\n        if result[&quot;image_name&quot;] == image_name:\n            coordinates = result[&quot;coordinates&quot;]\n            monitor = get_monitor_info(monitor_index)  # Get the monitor information as a dictionary\n            move_mouse_to_coordinates(monitor, coordinates)\n            pyautogui.click()  # Perform a left click\n            break\n    else:\n        print(f&quot;Image name &#x27;{image_name}&#x27; not found in the results.&quot;)\n\n\ndef move_mouse_to_coordinates(monitor, coordinates):\n    &quot;&quot;&quot;\n    Moves the mouse cursor to the specified coordinates on the monitor.\n\n    Args:\n        monitor (dict): A dictionary containing the monitor&#x27;s information.\n        coordinates (list): A list containing the coordinates [x1, y1, x2, y2].\n    &quot;&quot;&quot;\n    x1, y1, x2, y2 = coordinates\n    monitor_x, monitor_y = monitor.x, monitor.y\n    center_x = monitor_x + (x1 + x2) // 2\n    center_y = monitor_y + (y1 + y2) // 2\n    pyautogui.moveTo(center_x, center_y)\n    print(f&quot;Mouse moved to coordinates: ({center_x}, {center_y})&quot;)\n\ndef get_monitor_info(monitor_index):\n    &quot;&quot;&quot;\n    Gets information about the specified monitor.\n\n    Args:\n        monitor_index (int): The index of the monitor to get information about.\n\n    Returns:\n        dict: A dictionary containing the monitor&#x27;s information.\n    &quot;&quot;&quot;\n    monitors = screeninfo.get_monitors()\n\n    if monitor_index &gt;= len(monitors):\n        raise ValueError(f&quot;Monitor index {monitor_index} is out of range. There are only {len(monitors)} monitors.&quot;)\n\n    return monitors[monitor_index]\n\n# Modify the history_modifier function\ndef history_modifier(history):\n    &quot;&quot;&quot;\n    Modifies the chat history before the text generation in chat mode begins.\n    &quot;&quot;&quot;\n    # Clean the internal history\n    history[&quot;internal&quot;] = clean_chat_history(history[&quot;internal&quot;])\n    # Clean the visible history\n    history[&quot;visible&quot;] = clean_chat_history(history[&quot;visible&quot;])\n\n    # Inject the latest results.json into the internal history if the checkbox is checked\n    if global_vars.get(&quot;use_results_json&quot;, True):\n        results_json_path = &quot;extensions/Lucid_Autonomy/ImageOutputTest/results.json&quot;\n        with open(results_json_path, &#x27;r&#x27;) as f:\n            compressed_results = json.load(f)\n        latest_compressed_results = json.dumps(compressed_results, indent=4)\n        history[&quot;internal&quot;].append([&quot;&quot;, f&quot;&lt;START_COMPRESSED_RESULTS&gt;\\n{latest_compressed_results}\\n&lt;END_COMPRESSED_RESULTS&gt;&quot;])\n\n    # Extract all entries from the &quot;internal&quot; history\n    internal_entries = history[&quot;internal&quot;]\n    # Iterate over the &quot;internal&quot; history entries\n    for internal_index, internal_entry in enumerate(internal_entries):\n        # Extract the text content of the internal entry\n        internal_text = internal_entry[1]\n        # Search for the &quot;Image_File_Location:&quot; trigger phrase in the internal text\n        file_location_matches = re.findall(r&quot;Image_File_Location: (.+)$&quot;, internal_text, re.MULTILINE)\n        if file_location_matches:\n            # Iterate over each match found in the &quot;internal&quot; entry\n            for file_path in file_location_matches:\n                # Construct the full match string including the trigger phrase\n                full_match_string = f&quot;Image_File_Location: {file_path}&quot;\n                # Search for the exact same string in the &quot;visible&quot; history\n                for visible_entry in history[&quot;visible&quot;]:\n                    # Extract the text content of the visible entry\n                    visible_text = visible_entry[1]\n                    # If the &quot;visible&quot; entry contains the full match string\n                    if full_match_string in visible_text:\n                        # Split the &quot;visible&quot; text at the full match string\n                        _, after_match = visible_text.split(full_match_string, 1)\n                        # Find the position where the &quot;.png&quot; part ends in the &quot;internal&quot; text\n                        png_end_pos = internal_text.find(file_path) + len(file_path)\n                        # If the &quot;.png&quot; part is found and there is content after it\n                        if png_end_pos &lt; len(internal_text) and internal_text[png_end_pos] == &quot;\\n&quot;:\n                            # Extract the existing content after the &quot;.png&quot; part in the &quot;internal&quot; text\n                            _ = internal_text[png_end_pos:]\n                            # Replace the existing content after the &quot;.png&quot; part in the &quot;internal&quot; text\n                            # with the corresponding content from the &quot;visible&quot; text\n                            new_internal_text = internal_text[:png_end_pos] + after_match\n                            # Update the &quot;internal&quot; history entry with the new text\n                            history[&quot;internal&quot;][internal_index][1] = new_internal_text\n                        # If there is no content after the &quot;.png&quot; part in the &quot;internal&quot; text,\n                        # append the content from the &quot;visible&quot; text directly\n                        else:\n                            # Append the content after the full match string from the &quot;visible&quot; text\n                            history[&quot;internal&quot;][internal_index][1] += after_match\n\n        # Search for the &quot;Data_File_Location:&quot; trigger phrase in the internal text\n        data_file_location_matches = re.findall(r&quot;Data_File_Location: (.+)$&quot;, internal_text, re.MULTILINE)\n        if data_file_location_matches:\n            # Iterate over each match found in the &quot;internal&quot; entry\n            for file_path in data_file_location_matches:\n                # Construct the full match string including the trigger phrase\n                full_match_string = f&quot;Data_File_Location: {file_path}&quot;\n                # Search for the exact same string in the &quot;visible&quot; history\n                for visible_entry in history[&quot;visible&quot;]:\n                    # Extract the text content of the visible entry\n                    visible_text = visible_entry[1]\n                    # If the &quot;visible&quot; entry contains the full match string\n                    if full_match_string in visible_text:\n                        # Split the &quot;visible&quot; text at the full match string\n                        _, after_match = visible_text.split(full_match_string, 1)\n                        # Find the position where the &quot;.png&quot; part ends in the &quot;internal&quot; text\n                        png_end_pos = internal_text.find(file_path) + len(file_path)\n                        # If the &quot;.png&quot; part is found and there is content after it\n                        if png_end_pos &lt; len(internal_text) and internal_text[png_end_pos] == &quot;\\n&quot;:\n                            # Extract the existing content after the &quot;.png&quot; part in the &quot;internal&quot; text\n                            _ = internal_text[png_end_pos:]\n                            # Replace the existing content after the &quot;.png&quot; part in the &quot;internal&quot; text\n                            # with the corresponding content from the &quot;visible&quot; text\n                            new_internal_text = internal_text[:png_end_pos] + after_match\n                            # Update the &quot;internal&quot; history entry with the new text\n                            history[&quot;internal&quot;][internal_index][1] = new_internal_text\n                        # If there is no content after the &quot;.png&quot; part in the &quot;internal&quot; text,\n                        # append the content from the &quot;visible&quot; text directly\n                        else:\n                            # Append the content after the full match string from the &quot;visible&quot; text\n                            history[&quot;internal&quot;][internal_index][1] += after_match\n        # Search for the &quot;ARIA_File_Location:&quot; trigger phrase in the internal text\n        data_file_location_matches = re.findall(r&quot;ARIA_File_Location: (.+)$&quot;, internal_text, re.MULTILINE)\n        if data_file_location_matches:\n            # Iterate over each match found in the &quot;internal&quot; entry\n            for file_path in data_file_location_matches:\n                # Construct the full match string including the trigger phrase\n                full_match_string = f&quot;ARIA_File_Location: {file_path}&quot;\n                # Search for the exact same string in the &quot;visible&quot; history\n                for visible_entry in history[&quot;visible&quot;]:\n                    # Extract the text content of the visible entry\n                    visible_text = visible_entry[1]\n                    # If the &quot;visible&quot; entry contains the full match string\n                    if full_match_string in visible_text:\n                        # Split the &quot;visible&quot; text at the full match string\n                        _, after_match = visible_text.split(full_match_string, 1)\n                        # Find the position where the &quot;.png&quot; part ends in the &quot;internal&quot; text\n                        png_end_pos = internal_text.find(file_path) + len(file_path)\n                        # If the &quot;.png&quot; part is found and there is content after it\n                        if png_end_pos &lt; len(internal_text) and internal_text[png_end_pos] == &quot;\\n&quot;:\n                            # Extract the existing content after the &quot;.png&quot; part in the &quot;internal&quot; text\n                            _ = internal_text[png_end_pos:]\n                            # Replace the existing content after the &quot;.png&quot; part in the &quot;internal&quot; text\n                            # with the corresponding content from the &quot;visible&quot; text\n                            new_internal_text = internal_text[:png_end_pos] + after_match\n                            # Update the &quot;internal&quot; history entry with the new text\n                            history[&quot;internal&quot;][internal_index][1] = new_internal_text\n                        # If there is no content after the &quot;.png&quot; part in the &quot;internal&quot; text,\n                        # append the content from the &quot;visible&quot; text directly\n                        else:\n                            # Append the content after the full match string from the &quot;visible&quot; text\n                            history[&quot;internal&quot;][internal_index][1] += after_match\n\n    return history\n\ndef clean_chat_history(history):\n    &quot;&quot;&quot;\n    Cleans the chat history by removing all but the latest instance of the contents between the bookends.\n    &quot;&quot;&quot;\n    START_BOOKEND = &quot;&lt;START_COMPRESSED_RESULTS&gt;&quot;\n    END_BOOKEND = &quot;&lt;END_COMPRESSED_RESULTS&gt;&quot;\n\n    # Find all instances of the bookends\n    bookend_indices = []\n    for i, entry in enumerate(history):\n        if isinstance(entry, list) and len(entry) == 2:\n            if START_BOOKEND in entry[1] and END_BOOKEND in entry[1]:\n                bookend_indices.append(i)\n\n    # If there are multiple instances, remove all but the last one\n    if len(bookend_indices) &gt; 1:\n        for i in bookend_indices[:-1]:\n            history[i][1] = re.sub(f&quot;{START_BOOKEND}.*?{END_BOOKEND}&quot;, &quot;&quot;, history[i][1], flags=re.DOTALL)\n\n    return history\n\ndef append_compressed_results(output, compressed_results):\n    &quot;&quot;&quot;\n    Appends the compressed results to the output.\n    &quot;&quot;&quot;\n    START_BOOKEND = &quot;&lt;START_COMPRESSED_RESULTS&gt;&quot;\n    END_BOOKEND = &quot;&lt;END_COMPRESSED_RESULTS&gt;&quot;\n    output += f&quot;\\n{START_BOOKEND}\\n{json.dumps(compressed_results, indent=4)}\\n{END_BOOKEND}&quot;\n    return output\n\ndef text_input(text):\n    &quot;&quot;&quot;\n    Types the given text, replacing &#x27;/n&#x27; with newline characters.\n    &quot;&quot;&quot;\n    text = text.replace(&quot;/n&quot;, &quot;\\n&quot;)\n    pyautogui.typewrite(text)\n\ndef special_key(key):\n    &quot;&quot;&quot;\n    Presses the specified special key.\n    &quot;&quot;&quot;\n    if key == &quot;enter&quot;:\n        pyautogui.press(&quot;enter&quot;)\n    elif key == &quot;space&quot;:\n        pyautogui.press(&quot;space&quot;)\n    elif key == &quot;backspace&quot;:\n        pyautogui.press(&quot;backspace&quot;)\n    elif key == &quot;tab&quot;:\n        pyautogui.press(&quot;tab&quot;)\n    elif key == &quot;escape&quot;:\n        pyautogui.press(&quot;esc&quot;)\n    elif key == &quot;shift&quot;:\n        pyautogui.press(&quot;shift&quot;)\n    elif key == &quot;ctrl&quot;:\n        pyautogui.press(&quot;ctrl&quot;)\n    elif key == &quot;alt&quot;:\n        pyautogui.press(&quot;alt&quot;)\n    else:\n        print(f&quot;Unsupported special key: {key}&quot;)\n\ndef function_key(key):\n    &quot;&quot;&quot;\n    Presses the specified function key.\n    &quot;&quot;&quot;\n    if key.startswith(&quot;f&quot;) and key[1:].isdigit():\n        pyautogui.press(key)\n    else:\n        print(f&quot;Unsupported function key: {key}&quot;)\n\ndef key_combo(combo):\n    &quot;&quot;&quot;\n    Presses the specified key combination.\n    &quot;&quot;&quot;\n    keys = combo.split(&quot;+&quot;)\n    for key in keys:\n        if key in [&quot;ctrl&quot;, &quot;alt&quot;, &quot;shift&quot;]:\n            pyautogui.keyDown(key)\n        else:\n            pyautogui.press(key)\n    for key in keys:\n        if key in [&quot;ctrl&quot;, &quot;alt&quot;, &quot;shift&quot;]:\n            pyautogui.keyUp(key)\n\n# Main execution\nif __name__ == &quot;__main__&quot;:\n    # Launch the Gradio interface with the specified UI components\n    gr.Interface(\n        fn=ui,\n        inputs=None,\n        outputs=&quot;ui&quot;\n    ).launch()\n```",
            "To integrate the GOT-OCR and Aria models into `LucidVision.py`, you need to add the necessary functions and update the existing ones to handle these models. Below are the updated or new functions for `LucidVision.py`:\n\n### New Functions\n\n#### Load and Unload GOT-OCR Model\n```python\ndef load_got_ocr_model():\n    global got_ocr_model, got_ocr_tokenizer\n    os.environ[&quot;CUDA_VISIBLE_DEVICES&quot;] = &quot;0&quot;\n    torch.cuda.set_device(0)  # Explicitly set CUDA device\n\n    got_ocr_model = AutoModel.from_pretrained(config[&quot;got_ocr_model_id&quot;], trust_remote_code=True, low_cpu_mem_usage=True, device_map=&#x27;cuda:0&#x27;, use_safetensors=True).eval().cuda()\n    got_ocr_tokenizer = AutoTokenizer.from_pretrained(config[&quot;got_ocr_model_id&quot;], trust_remote_code=True)\n    print(&quot;GOT-OCR model loaded.&quot;)\n\ndef unload_got_ocr_model():\n    global got_ocr_model, got_ocr_tokenizer\n    if got_ocr_model is not None:\n        del got_ocr_model\n        del got_ocr_tokenizer\n        torch.cuda.empty_cache()\n        print(&quot;GOT-OCR model unloaded.&quot;)\n```\n\n#### Process with GOT-OCR Model\n```python\ndef process_with_got_ocr_model(image_path, got_mode, fine_grained_mode=&quot;&quot;, ocr_color=&quot;&quot;, ocr_box=&quot;&quot;):\n    load_got_ocr_model()\n    try:\n        if got_mode == &quot;plain texts OCR&quot;:\n            res = got_ocr_model.chat(got_ocr_tokenizer, image_path, ocr_type=&#x27;ocr&#x27;)\n            return res, None\n        elif got_mode == &quot;format texts OCR&quot;:\n            res = got_ocr_model.chat(got_ocr_tokenizer, image_path, ocr_type=&#x27;format&#x27;, render=True, save_render_file=result_path)\n        elif got_mode == &quot;plain multi-crop OCR&quot;:\n            res = got_ocr_model.chat_crop(got_ocr_tokenizer, image_path, ocr_type=&#x27;ocr&#x27;)\n            return res, None\n        elif got_mode == &quot;format multi-crop OCR&quot;:\n            res = got_ocr_model.chat_crop(got_ocr_tokenizer, image_path, ocr_type=&#x27;format&#x27;, render=True, save_render_file=result_path)\n        elif got_mode == &quot;plain fine-grained OCR&quot;:\n            res = got_ocr_model.chat(got_ocr_tokenizer, image_path, ocr_type=&#x27;ocr&#x27;, ocr_box=ocr_box, ocr_color=ocr_color)\n            return res, None\n        elif got_mode == &quot;format fine-grained OCR&quot;:\n            res = got_ocr_model.chat(got_ocr_tokenizer, image_path, ocr_type=&#x27;format&#x27;, ocr_box=ocr_box, ocr_color=ocr_color, render=True, save_render_file=result_path)\n\n        res_markdown = res\n\n        if &quot;format&quot; in got_mode and os.path.exists(result_path):\n            with open(result_path, &#x27;r&#x27;) as f:\n                html_content = f.read()\n            encoded_html = base64.b64encode(html_content.encode(&#x27;utf-8&#x27;)).decode(&#x27;utf-8&#x27;)\n            iframe_src = f&quot;data:text/html;base64,{encoded_html}&quot;\n            iframe = f&#x27;&lt;iframe src=&quot;{iframe_src}&quot; width=&quot;100%&quot; height=&quot;600px&quot;&gt;&lt;/iframe&gt;&#x27;\n            download_link = f&#x27;&lt;a href=&quot;data:text/html;base64,{encoded_html}&quot; download=&quot;result_{unique_id}.html&quot;&gt;Download Full Result&lt;/a&gt;&#x27;\n            return res_markdown, f&quot;{download_link}&lt;br&gt;{iframe}&quot;\n        else:\n            return res_markdown, None\n    except Exception as e:\n        return f&quot;Error: {str(e)}&quot;, None\n    finally:\n        unload_got_ocr_model()\n```\n\n#### Load and Unload Aria Model\n```python\ndef load_aria_model():\n    global aria_model, aria_processor\n    if aria_model is None:\n        print(&quot;Loading ARIA model...&quot;)\n        aria_model = AutoModelForCausalLM.from_pretrained(\n            config[&quot;aria_model_id&quot;],\n            device_map=&quot;auto&quot;,\n            torch_dtype=torch.bfloat16,\n            trust_remote_code=True\n        )\n        aria_processor = AutoProcessor.from_pretrained(\n            config[&quot;aria_model_id&quot;],\n            trust_remote_code=True\n        )\n        print(&quot;ARIA model loaded successfully.&quot;)\n    else:\n        print(&quot;ARIA model already loaded.&quot;)\n\ndef unload_aria_model():\n    global aria_model, aria_processor\n    if aria_model is not None:\n        print(&quot;Unloading ARIA model...&quot;)\n        # Move model to CPU before deletion\n        aria_model.cpu()\n        # Delete the model and processor\n        del aria_model\n        del aria_processor\n        # Set to None to indicate they&#x27;re unloaded\n        aria_model = None\n        aria_processor = None\n        # Clear CUDA cache\n        if torch.cuda.is_available():\n            torch.cuda.empty_cache()\n        # Run garbage collection\n        gc.collect()\n        print(&quot;ARIA model unloaded successfully.&quot;)\n    else:\n        print(&quot;ARIA model not loaded, nothing to unload.&quot;)\n\n    # Print current GPU memory usage\n    if torch.cuda.is_available():\n        print(f&quot;Current GPU memory allocated: {torch.cuda.memory_allocated() / 1e9:.2f} GB&quot;)\n        print(f&quot;Current GPU memory reserved: {torch.cuda.memory_reserved() / 1e9:.2f} GB&quot;)\n```\n\n#### Process with Aria Model\n```python\ndef process_with_aria_model(image_path, question):\n    global aria_model, aria_processor\n\n    if aria_model is None:\n        load_aria_model()\n\n    print(&quot;Processing image with ARIA model...&quot;)\n    image = Image.open(image_path).convert(&quot;RGB&quot;)\n    messages = [\n        {&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: [\n            {&quot;text&quot;: None, &quot;type&quot;: &quot;image&quot;},\n            {&quot;text&quot;: question, &quot;type&quot;: &quot;text&quot;},\n        ]}\n    ]\n\n    text = aria_processor.apply_chat_template(messages, add_generation_prompt=True)\n    inputs = aria_processor(text=text, images=image, return_tensors=&quot;pt&quot;)\n    inputs[&quot;pixel_values&quot;] = inputs[&quot;pixel_values&quot;].to(aria_model.dtype)\n    inputs = {k: v.to(aria_model.device) for k, v in inputs.items()}\n\n    with torch.inference_mode(), torch.cuda.amp.autocast(dtype=torch.bfloat16):\n        output = aria_model.generate(\n            **inputs,\n            max_new_tokens=1024,\n            stop_strings=[&quot;&lt;|im_end|&gt;&quot;],\n            tokenizer=aria_processor.tokenizer,\n            do_sample=True,\n            temperature=0.9,\n        )\n        output_ids = output[0][inputs[&quot;input_ids&quot;].shape[1]:]\n        result = aria_processor.decode(output_ids, skip_special_tokens=True)\n\n    print(&quot;Image processing complete.&quot;)\n    return result\n```\n\n### Updated Functions\n\n#### Update `process_with_vision_model`\n```python\ndef process_with_vision_model(user_input, image, selected_model):\n    global cuda_device\n    # Save the uploaded image to the specified directory with a timestamp\n    file_name = get_timestamped_filename()\n    file_path = image_history_dir / file_name\n    image.save(file_path, format=&#x27;PNG&#x27;)\n    print(f&quot;Image processed: {file_path}&quot;)\n\n    # Initialize an empty response string\n    vision_model_response = &quot;&quot;\n\n    # Check which vision model is currently selected\n    if selected_model == &quot;phiVision&quot;:\n        vision_model_response = generate_phi_vision(file_path, user_input)\n\n    elif selected_model == &quot;DeepSeek&quot;:\n        vision_model_response = generate_deepseek(file_path, user_input)\n\n    elif selected_model == &quot;paligemma&quot;:\n        vision_model_response = generate_paligemma(file_path, user_input)\n\n    elif selected_model == &quot;paligemma_cpu&quot;:\n        vision_model_response = generate_paligemma_cpu(file_path, user_input)\n\n    elif selected_model == &quot;minicpm_llama3&quot;:\n        vision_model_response = generate_minicpm_llama3(file_path, user_input)\n\n    elif selected_model == &quot;bunny&quot;:\n        vision_model_response = generate_bunny(file_path, user_input)\n\n    elif selected_model == &quot;got_ocr&quot;:\n        vision_model_response, _ = process_with_got_ocr_model(file_path, got_mode=&quot;plain texts OCR&quot;)\n\n    elif selected_model == &quot;aria&quot;:\n        vision_model_response = process_with_aria_model(file_path, user_input)\n\n    # Return the cleaned-up response from the vision model\n    return vision_model_response\n```\n\n#### Update `update_vision_model`\n```python\ndef update_vision_model(model_name):\n    global selected_vision_model\n    selected_vision_model = model_name\n    return model_name\n```\n\n#### Update `ui`\n```python\ndef ui():\n    # Create an image input component for the Gradio UI\n    image_input = gr.Image(label=&quot;Select an Image&quot;, type=&quot;pil&quot;, source=&quot;upload&quot;)\n    # Set up the event that occurs when an image is uploaded\n    image_input.change(\n        fn=save_and_print_image_path,\n        inputs=image_input,\n        outputs=None\n    )\n\n    # Create a text field for user input to the vision model\n    user_input_to_vision_model = gr.Textbox(label=&quot;Type your question or prompt for the vision model&quot;, lines=2,\n                                            placeholder=&quot;Enter your text here...&quot;)\n\n    # Create a button to trigger the vision model processing\n    vision_model_button = gr.Button(value=&quot;Ask Vision Model&quot;)\n\n    # Create a text field to display the vision model&#x27;s response\n    vision_model_response_output = gr.Textbox(\n        label=&quot;Vision Model Response&quot;,\n        lines=5,\n        placeholder=&quot;Response will appear here...&quot;\n    )\n\n    # Add radio buttons for vision model selection\n    vision_model_selection = gr.Radio(\n        choices=model_names + [&quot;got_ocr&quot;, &quot;aria&quot;],\n        value=config[&quot;default_vision_model&quot;],\n        label=&quot;Select Vision Model&quot;\n    )\n\n    # Add an event handler for the radio button selection\n    vision_model_selection.change(\n        fn=update_vision_model,\n        inputs=vision_model_selection,\n        outputs=None\n    )\n\n    cuda_devices_input = gr.Textbox(\n        value=cuda_device,\n        label=&quot;CUDA Device ID&quot;,\n        max_lines=1\n    )\n\n    cuda_devices_input.change(\n        fn=update_cuda_device,\n        inputs=cuda_devices_input,\n        outputs=None\n    )\n\n    # Set up the event that occurs when the vision model button is clicked\n    vision_model_button.click(\n        fn=process_with_vision_model,\n        inputs=[user_input_to_vision_model, image_input, vision_model_selection],\n        outputs=vision_model_response_output\n    )\n\n    # Return a column containing the UI components\n    return gr.Column(\n        [\n            image_input,\n            user_input_to_vision_model,\n            vision_model_button,\n            vision_model_response_output,\n            vision_model_selection\n        ]\n    )\n```\n\n### Update Config File\nAdd the following lines to the config file:\n```json\n{\n    &quot;got_ocr_model_id&quot;: &quot;/home/myself/Desktop/GOT_OCR/ModelGOT-OCR2_0/&quot;,\n    &quot;aria_model_id&quot;: &quot;/home/myself/Desktop/Aria/&quot;\n}\n```\n\nThese updates should integrate the GOT-OCR and Aria models into `LucidVision.py` while maintaining the existing functionality."
        ],
        [
            "What about the def output_modifier in the LucidVision.py code?\n\n```\n# Function to modify the output from the LLM before it is displayed to the user\ndef output_modifier(output, state, is_chat=False):\n    global cuda_device\n    # Search for the &quot;File location&quot; trigger phrase in the LLM&#x27;s output\n    file_location_matches = file_location_pattern.findall(output)\n    if file_location_matches:\n        # Extract the first match (assuming only one file location per output)\n        file_path = file_location_matches[0]\n        # Extract the questions for the vision model\n        questions_section, _ = output.split(f&quot;File location: {file_path}&quot;, 1)\n        # Remove all newlines from the questions section and replace them with spaces\n        questions = &quot; &quot;.join(questions_section.strip().splitlines())\n\n        # Initialize an empty response string\n        vision_model_response = &quot;&quot;\n\n        # Check which vision model is currently selected\n        if selected_vision_model == &quot;phiVision&quot;:\n            vision_model_response = generate_phi_vision(file_path, questions)\n\n        elif selected_vision_model == &quot;DeepSeek&quot;:\n            vision_model_response = generate_deepseek(file_path, questions)\n\n        elif selected_vision_model == &quot;paligemma&quot;:\n            vision_model_response = generate_paligemma(file_path, questions)\n\n        elif selected_vision_model == &quot;paligemma_cpu&quot;:\n            vision_model_response = generate_paligemma_cpu(file_path, questions)\n\n        elif selected_vision_model == &quot;minicpm_llama3&quot;:\n            vision_model_response = generate_minicpm_llama3(file_path, questions)\n\n        elif selected_vision_model == &quot;bunny&quot;:\n            vision_model_response = generate_bunny(file_path, questions)\n\n        # Append the vision model&#x27;s responses to the output\n        output_with_responses = f&quot;{output}\\n\\nVision Model Responses:\\n{vision_model_response}&quot;\n        return output_with_responses\n    # If no file location is found, return the output as is\n    return output\n```",
            "To update the `output_modifier` function to handle the new GOT-OCR and Aria models, you need to add conditions for these models in the function. Here is the updated `output_modifier` function:\n\n### Updated `output_modifier` Function\n```python\n# Function to modify the output from the LLM before it is displayed to the user\ndef output_modifier(output, state, is_chat=False):\n    global cuda_device\n    # Search for the &quot;File location&quot; trigger phrase in the LLM&#x27;s output\n    file_location_matches = file_location_pattern.findall(output)\n    if file_location_matches:\n        # Extract the first match (assuming only one file location per output)\n        file_path = file_location_matches[0]\n        # Extract the questions for the vision model\n        questions_section, _ = output.split(f&quot;File location: {file_path}&quot;, 1)\n        # Remove all newlines from the questions section and replace them with spaces\n        questions = &quot; &quot;.join(questions_section.strip().splitlines())\n\n        # Initialize an empty response string\n        vision_model_response = &quot;&quot;\n\n        # Check which vision model is currently selected\n        if selected_vision_model == &quot;phiVision&quot;:\n            vision_model_response = generate_phi_vision(file_path, questions)\n\n        elif selected_vision_model == &quot;DeepSeek&quot;:\n            vision_model_response = generate_deepseek(file_path, questions)\n\n        elif selected_vision_model == &quot;paligemma&quot;:\n            vision_model_response = generate_paligemma(file_path, questions)\n\n        elif selected_vision_model == &quot;paligemma_cpu&quot;:\n            vision_model_response = generate_paligemma_cpu(file_path, questions)\n\n        elif selected_vision_model == &quot;minicpm_llama3&quot;:\n            vision_model_response = generate_minicpm_llama3(file_path, questions)\n\n        elif selected_vision_model == &quot;bunny&quot;:\n            vision_model_response = generate_bunny(file_path, questions)\n\n        elif selected_vision_model == &quot;got_ocr&quot;:\n            vision_model_response, _ = process_with_got_ocr_model(file_path, got_mode=&quot;plain texts OCR&quot;)\n\n        elif selected_vision_model == &quot;aria&quot;:\n            vision_model_response = process_with_aria_model(file_path, questions)\n\n        # Append the vision model&#x27;s responses to the output\n        output_with_responses = f&quot;{output}\\n\\nVision Model Responses:\\n{vision_model_response}&quot;\n        return output_with_responses\n    # If no file location is found, return the output as is\n    return output\n```\n\n### Summary of Changes\n1. **Added Conditions for GOT-OCR and Aria Models**: The `output_modifier` function now includes conditions to handle the GOT-OCR and Aria models.\n2. **Process with GOT-OCR Model**: The `process_with_got_ocr_model` function is called when the selected model is `got_ocr`.\n3. **Process with Aria Model**: The `process_with_aria_model` function is called when the selected model is `aria`.\n\nThese updates ensure that the `output_modifier` function can handle the new models and integrate their responses into the output."
        ],
        [
            "In this function:\n\n```\ndef process_with_got_ocr_model(image_path, got_mode, fine_grained_mode=&quot;&quot;, ocr_color=&quot;&quot;, ocr_box=&quot;&quot;):\n    load_got_ocr_model()\n    try:\n        if got_mode == &quot;plain texts OCR&quot;:\n            res = got_ocr_model.chat(got_ocr_tokenizer, image_path, ocr_type=&#x27;ocr&#x27;)\n            return res, None\n        elif got_mode == &quot;format texts OCR&quot;:\n            res = got_ocr_model.chat(got_ocr_tokenizer, image_path, ocr_type=&#x27;format&#x27;, render=True, save_render_file=result_path)\n        elif got_mode == &quot;plain multi-crop OCR&quot;:\n            res = got_ocr_model.chat_crop(got_ocr_tokenizer, image_path, ocr_type=&#x27;ocr&#x27;)\n            return res, None\n        elif got_mode == &quot;format multi-crop OCR&quot;:\n            res = got_ocr_model.chat_crop(got_ocr_tokenizer, image_path, ocr_type=&#x27;format&#x27;, render=True, save_render_file=result_path)\n        elif got_mode == &quot;plain fine-grained OCR&quot;:\n            res = got_ocr_model.chat(got_ocr_tokenizer, image_path, ocr_type=&#x27;ocr&#x27;, ocr_box=ocr_box, ocr_color=ocr_color)\n            return res, None\n        elif got_mode == &quot;format fine-grained OCR&quot;:\n            res = got_ocr_model.chat(got_ocr_tokenizer, image_path, ocr_type=&#x27;format&#x27;, ocr_box=ocr_box, ocr_color=ocr_color, render=True, save_render_file=result_path)\n\n        res_markdown = res\n\n        if &quot;format&quot; in got_mode and os.path.exists(result_path):\n            with open(result_path, &#x27;r&#x27;) as f:\n                html_content = f.read()\n            encoded_html = base64.b64encode(html_content.encode(&#x27;utf-8&#x27;)).decode(&#x27;utf-8&#x27;)\n            iframe_src = f&quot;data:text/html;base64,{encoded_html}&quot;\n            iframe = f&#x27;&lt;iframe src=&quot;{iframe_src}&quot; width=&quot;100%&quot; height=&quot;600px&quot;&gt;&lt;/iframe&gt;&#x27;\n            download_link = f&#x27;&lt;a href=&quot;data:text/html;base64,{encoded_html}&quot; download=&quot;result_{unique_id}.html&quot;&gt;Download Full Result&lt;/a&gt;&#x27;\n            return res_markdown, f&quot;{download_link}&lt;br&gt;{iframe}&quot;\n        else:\n            return res_markdown, None\n    except Exception as e:\n        return f&quot;Error: {str(e)}&quot;, None\n    finally:\n        unload_got_ocr_model()\n```\nI&#x27;m seeing this error: undefined name result_path",
            "The error you&#x27;re encountering is due to the `result_path` variable not being defined in the `process_with_got_ocr_model` function. To fix this, you need to define `result_path` and `unique_id` within the function. Here is the corrected version of the function:\n\n### Updated `process_with_got_ocr_model` Function\n```python\nimport uuid\nimport base64\n\ndef process_with_got_ocr_model(image_path, got_mode, fine_grained_mode=&quot;&quot;, ocr_color=&quot;&quot;, ocr_box=&quot;&quot;):\n    load_got_ocr_model()\n    try:\n        unique_id = str(uuid.uuid4())\n        result_path = f&quot;extensions/Lucid_Autonomy/ImageOutputTest/result_{unique_id}.html&quot;\n\n        if got_mode == &quot;plain texts OCR&quot;:\n            res = got_ocr_model.chat(got_ocr_tokenizer, image_path, ocr_type=&#x27;ocr&#x27;)\n            return res, None\n        elif got_mode == &quot;format texts OCR&quot;:\n            res = got_ocr_model.chat(got_ocr_tokenizer, image_path, ocr_type=&#x27;format&#x27;, render=True, save_render_file=result_path)\n        elif got_mode == &quot;plain multi-crop OCR&quot;:\n            res = got_ocr_model.chat_crop(got_ocr_tokenizer, image_path, ocr_type=&#x27;ocr&#x27;)\n            return res, None\n        elif got_mode == &quot;format multi-crop OCR&quot;:\n            res = got_ocr_model.chat_crop(got_ocr_tokenizer, image_path, ocr_type=&#x27;format&#x27;, render=True, save_render_file=result_path)\n        elif got_mode == &quot;plain fine-grained OCR&quot;:\n            res = got_ocr_model.chat(got_ocr_tokenizer, image_path, ocr_type=&#x27;ocr&#x27;, ocr_box=ocr_box, ocr_color=ocr_color)\n            return res, None\n        elif got_mode == &quot;format fine-grained OCR&quot;:\n            res = got_ocr_model.chat(got_ocr_tokenizer, image_path, ocr_type=&#x27;format&#x27;, ocr_box=ocr_box, ocr_color=ocr_color, render=True, save_render_file=result_path)\n\n        res_markdown = res\n\n        if &quot;format&quot; in got_mode and os.path.exists(result_path):\n            with open(result_path, &#x27;r&#x27;) as f:\n                html_content = f.read()\n            encoded_html = base64.b64encode(html_content.encode(&#x27;utf-8&#x27;)).decode(&#x27;utf-8&#x27;)\n            iframe_src = f&quot;data:text/html;base64,{encoded_html}&quot;\n            iframe = f&#x27;&lt;iframe src=&quot;{iframe_src}&quot; width=&quot;100%&quot; height=&quot;600px&quot;&gt;&lt;/iframe&gt;&#x27;\n            download_link = f&#x27;&lt;a href=&quot;data:text/html;base64,{encoded_html}&quot; download=&quot;result_{unique_id}.html&quot;&gt;Download Full Result&lt;/a&gt;&#x27;\n            return res_markdown, f&quot;{download_link}&lt;br&gt;{iframe}&quot;\n        else:\n            return res_markdown, None\n    except Exception as e:\n        return f&quot;Error: {str(e)}&quot;, None\n    finally:\n        unload_got_ocr_model()\n```\n\n### Summary of Changes\n1. **Defined `result_path` and `unique_id`**: These variables are now defined within the function to ensure they are available when needed.\n2. **Imported Required Modules**: Added `import uuid` and `import base64` to handle the generation of unique IDs and encoding of HTML content.\n\nThese changes should resolve the `undefined name result_path` error and ensure that the function works correctly."
        ],
        [
            "Okay, I get this error in the &quot;Vision Model Response&quot; UI window when I try to use the got-ocr model:\n```\nError: &#x27;PosixPath&#x27; object has no attribute &#x27;startswith&#x27;\n```\n\nThis is what I see in the terminal:\n\n```\n14:47:14-266842 INFO     Starting Text generation web UI                        \n14:47:14-268710 INFO     Loading settings from &quot;settings.yaml&quot;                  \n14:47:14-270854 INFO     Loading the extension                                  \n                         &quot;text-generation-webui-model_ducking&quot;                  \n14:47:14-329797 INFO     Loading the extension &quot;Lucid_Vision&quot;                   \n14:47:14-938519 INFO     Loading the extension &quot;Lucid_Autonomy&quot;                 \n\nRunning on local URL:  http://127.0.0.1:7861\n\nImage selected: /home/myself/Desktop/OobV115/text-generation-webui/extensions/Lucid_Vision/Image_History/image_20241020_144815.png\nImage processed: /home/myself/Desktop/OobV115/text-generation-webui/extensions/Lucid_Vision/Image_History/image_20241020_144818.png\nGOT-OCR model loaded.\nGOT-OCR model unloaded.\n```",
            "The error `&#x27;PosixPath&#x27; object has no attribute &#x27;startswith&#x27;` suggests that there is an issue with how the file path is being handled. The `PosixPath` object from the `pathlib` module does not have a `startswith` method. Instead, you should use the `str` method to convert the `PosixPath` object to a string before using `startswith`.\n\nLet&#x27;s update the `process_with_got_ocr_model` function to handle this correctly. Additionally, we&#x27;ll ensure that the `result_path` is correctly defined and used.\n\n### Updated `process_with_got_ocr_model` Function\n```python\nimport uuid\nimport base64\n\ndef process_with_got_ocr_model(image_path, got_mode, fine_grained_mode=&quot;&quot;, ocr_color=&quot;&quot;, ocr_box=&quot;&quot;):\n    load_got_ocr_model()\n    try:\n        unique_id = str(uuid.uuid4())\n        result_path = f&quot;extensions/Lucid_Autonomy/ImageOutputTest/result_{unique_id}.html&quot;\n\n        if got_mode == &quot;plain texts OCR&quot;:\n            res = got_ocr_model.chat(got_ocr_tokenizer, str(image_path), ocr_type=&#x27;ocr&#x27;)\n            return res, None\n        elif got_mode == &quot;format texts OCR&quot;:\n            res = got_ocr_model.chat(got_ocr_tokenizer, str(image_path), ocr_type=&#x27;format&#x27;, render=True, save_render_file=result_path)\n        elif got_mode == &quot;plain multi-crop OCR&quot;:\n            res = got_ocr_model.chat_crop(got_ocr_tokenizer, str(image_path), ocr_type=&#x27;ocr&#x27;)\n            return res, None\n        elif got_mode == &quot;format multi-crop OCR&quot;:\n            res = got_ocr_model.chat_crop(got_ocr_tokenizer, str(image_path), ocr_type=&#x27;format&#x27;, render=True, save_render_file=result_path)\n        elif got_mode == &quot;plain fine-grained OCR&quot;:\n            res = got_ocr_model.chat(got_ocr_tokenizer, str(image_path), ocr_type=&#x27;ocr&#x27;, ocr_box=ocr_box, ocr_color=ocr_color)\n            return res, None\n        elif got_mode == &quot;format fine-grained OCR&quot;:\n            res = got_ocr_model.chat(got_ocr_tokenizer, str(image_path), ocr_type=&#x27;format&#x27;, ocr_box=ocr_box, ocr_color=ocr_color, render=True, save_render_file=result_path)\n\n        res_markdown = res\n\n        if &quot;format&quot; in got_mode and os.path.exists(result_path):\n            with open(result_path, &#x27;r&#x27;) as f:\n                html_content = f.read()\n            encoded_html = base64.b64encode(html_content.encode(&#x27;utf-8&#x27;)).decode(&#x27;utf-8&#x27;)\n            iframe_src = f&quot;data:text/html;base64,{encoded_html}&quot;\n            iframe = f&#x27;&lt;iframe src=&quot;{iframe_src}&quot; width=&quot;100%&quot; height=&quot;600px&quot;&gt;&lt;/iframe&gt;&#x27;\n            download_link = f&#x27;&lt;a href=&quot;data:text/html;base64,{encoded_html}&quot; download=&quot;result_{unique_id}.html&quot;&gt;Download Full Result&lt;/a&gt;&#x27;\n            return res_markdown, f&quot;{download_link}&lt;br&gt;{iframe}&quot;\n        else:\n            return res_markdown, None\n    except Exception as e:\n        return f&quot;Error: {str(e)}&quot;, None\n    finally:\n        unload_got_ocr_model()\n```\n\n### Summary of Changes\n1. **Convert `image_path` to String**: The `image_path` is converted to a string using `str(image_path)` before passing it to the `got_ocr_model.chat` method.\n2. **Defined `result_path` and `unique_id`**: These variables are now defined within the function to ensure they are available when needed.\n3. **Imported Required Modules**: Added `import uuid` and `import base64` to handle the generation of unique IDs and encoding of HTML content.\n\nThese changes should resolve the `&#x27;PosixPath&#x27; object has no attribute &#x27;startswith&#x27;` error and ensure that the function works correctly."
        ],
        [
            "Yippy!!! The GOT-OCR model works :3 Good LLM *head pats*\n\nOkay, now I&#x27;m trying the aria model and am getting this error:\n\n```\n                         &quot;text-generation-webui-model_ducking&quot;                  \n14:51:36-018775 INFO     Loading the extension &quot;Lucid_Vision&quot;                   \n14:51:36-627019 INFO     Loading the extension &quot;Lucid_Autonomy&quot;                 \n\nRunning on local URL:  http://127.0.0.1:7861\n\nImage selected: /home/myself/Desktop/OobV115/text-generation-webui/extensions/Lucid_Vision/Image_History/image_20241020_145144.png\nImage processed: /home/myself/Desktop/OobV115/text-generation-webui/extensions/Lucid_Vision/Image_History/image_20241020_145147.png\nGOT-OCR model loaded.\nGOT-OCR model unloaded.\nNo image selected yet.\nImage selected: /home/myself/Desktop/OobV115/text-generation-webui/extensions/Lucid_Vision/Image_History/image_20241020_145236.png\nImage processed: /home/myself/Desktop/OobV115/text-generation-webui/extensions/Lucid_Vision/Image_History/image_20241020_145238.png\nTraceback (most recent call last):\n  File &quot;/home/myself/Desktop/OobV115/text-generation-webui/installer_files/env/lib/python3.11/site-packages/gradio/queueing.py&quot;, line 527, in process_events\n    response = await route_utils.call_process_api(\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File &quot;/home/myself/Desktop/OobV115/text-generation-webui/installer_files/env/lib/python3.11/site-packages/gradio/route_utils.py&quot;, line 261, in call_process_api\n    output = await app.get_blocks().process_api(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File &quot;/home/myself/Desktop/OobV115/text-generation-webui/installer_files/env/lib/python3.11/site-packages/gradio/blocks.py&quot;, line 1786, in process_api\n    result = await self.call_function(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File &quot;/home/myself/Desktop/OobV115/text-generation-webui/installer_files/env/lib/python3.11/site-packages/gradio/blocks.py&quot;, line 1338, in call_function\n    prediction = await anyio.to_thread.run_sync(\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File &quot;/home/myself/Desktop/OobV115/text-generation-webui/installer_files/env/lib/python3.11/site-packages/anyio/to_thread.py&quot;, line 56, in run_sync\n    return await get_async_backend().run_sync_in_worker_thread(\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File &quot;/home/myself/Desktop/OobV115/text-generation-webui/installer_files/env/lib/python3.11/site-packages/anyio/_backends/_asyncio.py&quot;, line 2441, in run_sync_in_worker_thread\n    return await future\n           ^^^^^^^^^^^^\n  File &quot;/home/myself/Desktop/OobV115/text-generation-webui/installer_files/env/lib/python3.11/site-packages/anyio/_backends/_asyncio.py&quot;, line 943, in run\n    result = context.run(func, *args)\n             ^^^^^^^^^^^^^^^^^^^^^^^^\n  File &quot;/home/myself/Desktop/OobV115/text-generation-webui/installer_files/env/lib/python3.11/site-packages/gradio/utils.py&quot;, line 759, in wrapper\n    response = f(*args, **kwargs)\n               ^^^^^^^^^^^^^^^^^^\n  File &quot;/home/myself/Desktop/OobV115/text-generation-webui/extensions/Lucid_Vision/script.py&quot;, line 640, in process_with_vision_model\n    vision_model_response = process_with_aria_model(file_path, user_input)\n                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File &quot;/home/myself/Desktop/OobV115/text-generation-webui/extensions/Lucid_Vision/script.py&quot;, line 484, in process_with_aria_model\n    if aria_model is None:\n       ^^^^^^^^^^\nNameError: name &#x27;aria_model&#x27; is not defined\n\n```",
            "The error `NameError: name &#x27;aria_model&#x27; is not defined` indicates that the `aria_model` variable is not defined in the scope where it is being used. This typically happens if the variable is not declared as a global variable or if it is not properly initialized.\n\nTo fix this, ensure that `aria_model` and `aria_processor` are declared as global variables and properly initialized in the `load_aria_model` function. Additionally, make sure that the `process_with_aria_model` function is correctly referencing these global variables.\n\nHere is the updated code to address these issues:\n\n### Updated `load_aria_model` Function\n```python\naria_model = None\naria_processor = None\n\ndef load_aria_model():\n    global aria_model, aria_processor\n    if aria_model is None:\n        print(&quot;Loading ARIA model...&quot;)\n        aria_model = AutoModelForCausalLM.from_pretrained(\n            config[&quot;aria_model_id&quot;],\n            device_map=&quot;auto&quot;,\n            torch_dtype=torch.bfloat16,\n            trust_remote_code=True\n        )\n        aria_processor = AutoProcessor.from_pretrained(\n            config[&quot;aria_model_id&quot;],\n            trust_remote_code=True\n        )\n        print(&quot;ARIA model loaded successfully.&quot;)\n    else:\n        print(&quot;ARIA model already loaded.&quot;)\n```\n\n### Updated `unload_aria_model` Function\n```python\ndef unload_aria_model():\n    global aria_model, aria_processor\n    if aria_model is not None:\n        print(&quot;Unloading ARIA model...&quot;)\n        # Move model to CPU before deletion\n        aria_model.cpu()\n        # Delete the model and processor\n        del aria_model\n        del aria_processor\n        # Set to None to indicate they&#x27;re unloaded\n        aria_model = None\n        aria_processor = None\n        # Clear CUDA cache\n        if torch.cuda.is_available():\n            torch.cuda.empty_cache()\n        # Run garbage collection\n        gc.collect()\n        print(&quot;ARIA model unloaded successfully.&quot;)\n    else:\n        print(&quot;ARIA model not loaded, nothing to unload.&quot;)\n\n    # Print current GPU memory usage\n    if torch.cuda.is_available():\n        print(f&quot;Current GPU memory allocated: {torch.cuda.memory_allocated() / 1e9:.2f} GB&quot;)\n        print(f&quot;Current GPU memory reserved: {torch.cuda.memory_reserved() / 1e9:.2f} GB&quot;)\n```\n\n### Updated `process_with_aria_model` Function\n```python\ndef process_with_aria_model(image_path, question):\n    global aria_model, aria_processor\n\n    if aria_model is None:\n        load_aria_model()\n\n    print(&quot;Processing image with ARIA model...&quot;)\n    image = Image.open(image_path).convert(&quot;RGB&quot;)\n    messages = [\n        {&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: [\n            {&quot;text&quot;: None, &quot;type&quot;: &quot;image&quot;},\n            {&quot;text&quot;: question, &quot;type&quot;: &quot;text&quot;},\n        ]}\n    ]\n\n    text = aria_processor.apply_chat_template(messages, add_generation_prompt=True)\n    inputs = aria_processor(text=text, images=image, return_tensors=&quot;pt&quot;)\n    inputs[&quot;pixel_values&quot;] = inputs[&quot;pixel_values&quot;].to(aria_model.dtype)\n    inputs = {k: v.to(aria_model.device) for k, v in inputs.items()}\n\n    with torch.inference_mode(), torch.cuda.amp.autocast(dtype=torch.bfloat16):\n        output = aria_model.generate(\n            **inputs,\n            max_new_tokens=1024,\n            stop_strings=[&quot;&lt;|im_end|&gt;&quot;],\n            tokenizer=aria_processor.tokenizer,\n            do_sample=True,\n            temperature=0.9,\n        )\n        output_ids = output[0][inputs[&quot;input_ids&quot;].shape[1]:]\n        result = aria_processor.decode(output_ids, skip_special_tokens=True)\n\n    print(&quot;Image processing complete.&quot;)\n    return result\n```\n\n### Summary of Changes\n1. **Declared Global Variables**: `aria_model` and `aria_processor` are declared as global variables.\n2. **Updated `load_aria_model` Function**: Ensures that `aria_model` and `aria_processor` are properly initialized.\n3. **Updated `unload_aria_model` Function**: Ensures that `aria_model` and `aria_processor` are properly unloaded and memory is cleared.\n4. **Updated `process_with_aria_model` Function**: Ensures that `aria_model` and `aria_processor` are correctly referenced and used.\n\nThese changes should resolve the `NameError: name &#x27;aria_model&#x27; is not defined` error and ensure that the ARIA model works correctly."
        ]
    ]
}